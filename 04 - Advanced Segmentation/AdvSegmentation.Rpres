```{r global_setup,  warning=FALSE, cache=FALSE,echo=FALSE,error=FALSE,results='hide'}
require(knitr)
# default settings, # settings for presentation version
echo.val<-F
fig.height<-5
dpi<-150
cache<-T
fig.path<-"pres_figures/"
cache.path<-"pres_cache/"

if(exists("printed")) { # settings for printed version (if the variable exists)
  echo.val<-T # show code
  fig.height<-3
  dpi<-150
  cache<-T
  fig.path<-"print_figures/"
  cache.path<-"print_cache/"
}


opts_chunk$set(dpi=dpi,cache=cache,
               cache.path=cache.path,results='hide',
               warning=F,fig.align='center',echo=echo.val,
               fig.height=fig.height,fig.path=fig.path,message=F) #dev="CairoPNG"
```

```{r script_setup,results='hide',cache=FALSE}
require(ggplot2)
require(lattice) # nicer scatter plots
require(plyr)
require(grid) # contains the arrow function
require(biOps)
require(doMC) # for parallel code
require(EBImage)
## To install EBImage
# source("http://bioconductor.org/biocLite.R")
# biocLite("EBImage")

# start parallel environment
registerDoMC()
# functions for converting images back and forth
im.to.df<-function(in.img) {
    out.im<-expand.grid(x=1:nrow(in.img),y=1:ncol(in.img))
    out.im$val<-as.vector(in.img)
    out.im
}
df.to.im<-function(in.df,val.col="val",inv=F) {
  in.vals<-in.df[[val.col]]
  if(class(in.vals[1])=="logical") in.vals<-as.integer(in.vals*255)
  if(inv) in.vals<-255-in.vals
  out.mat<-matrix(in.vals,nrow=length(unique(in.df$x)),byrow=F)
  attr(out.mat,"type")<-"grey"
  out.mat
}
ddply.cutcols<-function(...,cols=1) {
  # run standard ddply command
  cur.table<-ddply(...)
  cutlabel.fixer<-function(oVal) {
    sapply(oVal,function(x) {
      cnv<-as.character(x)
      mean(as.numeric(strsplit(substr(cnv,2,nchar(cnv)-1),",")[[1]]))
    })
  }
  cutname.fixer<-function(c.str) {
    s.str<-strsplit(c.str,"(",fixed=T)[[1]]
    t.str<-strsplit(paste(s.str[c(2:length(s.str))],collapse="("),",")[[1]]
    paste(t.str[c(1:length(t.str)-1)],collapse=",")
  }
  for(i in c(1:cols)) {
    cur.table[,i]<-cutlabel.fixer(cur.table[,i])
    names(cur.table)[i]<-cutname.fixer(names(cur.table)[i])
  }
  cur.table
}
```

Quantitative Big Imaging  
========================================================
author: Kevin Mader
date: 13 March 2014
width: 1440
height: 900
transition: rotate

## Advanced Segmentation and Labeling


Course Outline
========================================================
- 20th February - Introductory Lecture
- 27th February - Filtering and Image Enhancement (A. Kaestner)
- 6th March - Basic Segmentation, Discrete Binary Structures
- 13th March - **Advanced Segmentation**
- 20th March - Analyzing Single Objects
- 27th March -  Analyzing Complex Objects
- 3rd April -  Spatial Distribution
- 10th April -  Statistics and Reproducibility
- 17th April - Dynamic Experiments
- 8th May - Big Data
- 15th May - Guest Lecture - Applications in Material Science
- 22th May - Project Presentations

Literature / Useful References
========================================================
- Jean Claude, Morphometry with R
 - [Online](http://link.springer.com/book/10.1007%2F978-0-387-77789-4) through ETHZ
 - [Buy it](http://www.amazon.com/Morphometrics-R-Use-Julien-Claude/dp/038777789X)
- John C. Russ, “The Image Processing Handbook”,(Boca Raton, CRC Press)
 - Available [online](http://dx.doi.org/10.1201/9780203881095) within domain ethz.ch (or proxy.ethz.ch / public VPN) 


Lesson Outline
========================================================
- Motivation
 - Many Samples
 - Difficult Samples 
- Thresholding
 - Other types of images
 - Selecting a good threshold
- Implementation
- Morphology
- Applications

What we covered last time
========================================================

- Understanding models and histograms
- Selecting a threshold
- Applying morphological operations
- Partial Volume Effect Caution

Where segmentation fails: Inconsistent Illumination
========================================================

With inconsistent or every changing illumination it may not be possible to apply the same threshold to every image. 

```{r, fig.cap="Cell Colony",fig.height=7}
cellImage<-im.to.df(jpeg::readJPEG("ext-figures/Cell_Colony.jpg"))
il.vals<-runif(4,min=0.2,max=1/0.2)
im.vals<-ldply(1:length(il.vals),function(il.idx,th.val=0.75)
  cbind(cellImage[,c("x","y")],
        val=cellImage$val*il.vals[il.idx],
        in.thresh=ifelse(cellImage$val*il.vals[il.idx]<th.val,"Cells","Background"),
        il.val=il.vals[il.idx],
        th.val=th.val
        ))
im.vals$il.val<-as.numeric(factor(im.vals$il.val))
ggplot(im.vals,aes(x=x,y=y,fill=val))+
  geom_raster()+facet_wrap(~il.val)+
  labs(fill="Intensity")+
  theme_bw(20)+coord_equal()
```

***

```{r, fig.cap="Cell Colony with thresholds",fig.height=7}
ggplot(im.vals,aes(x=x,y=y,fill=in.thresh))+
  geom_raster()+facet_wrap(~il.val)+
  labs(fill="Phase")+
  theme_bw(20)+coord_equal()

```





Where segmentation fails: Canaliculi
========================================================
![Bone Slice](ext-figures/bonegfiltslice.png)
Here is a bone slice
1. Find the larger cellular structures (osteocyte lacunae)
1. FInd the small channels which connect them together

***

The first task is easy using a threshold and size criteria (we know how big the cells should be)

The second is much more difficult 

Where segmentation fails: Brain Cortex
========================================================
- The cortex is barely visible to the human eye
- Tiny structures hint at where cortex is located
```{r, fig.cap="Brain with Threshold",fig.height=5}
alz.df<-im.to.df(t(png::readPNG("ext-figures/cortex.png")))
ggplot(alz.df,aes(x=x,y=518-y))+
  geom_raster(aes(fill=val))+
  labs(fill="Electron Density",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

***

- A simple threshold is insufficient to finding the cortical structures
- Other filtering techniques are unlikely to magicially fix this problem
```{r, fig.cap="Brain with Threshold",fig.height=5}
ggplot(alz.df,aes(x=x,y=518-y))+
  geom_raster(aes(fill=cut_interval(val,4)))+
  labs(fill="Segmented Phases",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```


Automated Threshold Selection
========================================================
type:alert
![Many possible automated techniques](ext-figures/automaticthresh.png)

***

Given that applying a threshold is such a common and signficant step, there have been many tools developed to automatically (unsupervised) perform it. A particularly important step in setups where images are rarely consistent such as outdoor imaging which has varying lighting (sun, clouds). The methods are based on several basic principles. 

### Histogram-based methods
Just like we visually inspect a histogram an algorithm can examine the histogram and find local minimums between two peaks, maximum / minimum entropy and other factors

- Otsu, Isodata, Intermodes, etc

### Image based Methods
These look at the statistics of the thresheld image themselves (like entropy) to estimate the threshold  


### Results-based Methods
These search for a threshold which delivers the desired results in the final objects. For example if you know you have an image of cells and each cell is between 200-10000 pixels the algorithm runs thresholds until the objects are of the desired size
- More specific requirements need to be implemented manually


Fiji -> Adjust -> Auto Threshold
========================================================
There are many methods and they can be complicated to implement yourself. FIJI offers many of them as built in functions so you can automatically try all of them on your image
![Many possible automated techniques](ext-figures/tryall.png)

Pitfalls
===
While an incredibly useful tool, there are many potential pitfalls to these automated techniques. 

### Histogram-based

These methods are very sensitive to the distribution of pixels in your image and may work really well on images with equal amounts of each phase but work horribly on images which have very high amounts of one phase compared to the others

### Image-based

These methods are sensitive to noise and a large noise content in the image can change statistics like entropy significantly. 

### Results-based

These methods are inherently biased by the expectations you have. If you want to find objects between 200 and 1000 pixels you will, they just might not be anything meaningful.

Realistic Approaches for Dealing with these Shortcomings
===

Imaging science rarely represents the ideal world and will never be 100% perfect. At some point we need to write our master's thesis, defend, or publish a paper. These are approaches for more qualitative assessment we will later cover how to do this a bit more robustly with quantitative approaches

### Model-based

One approach is to try and simulate everything (including noise) as well as possible and to apply these techniques to many realizations of the same image and qualitatively keep track of how many of the results accurately identify your phase or not. Hint: >95% seems to convince most biologists

### Sample-based

Apply the methods to each sample and keep track of which threshold was used for each one. Go back and apply each threshold to each sample in the image and keep track of how many of them are correct enough to be used for further study.

### Worst-case Scenario

Come up with the worst-case scenario (noise, misalignment, etc) and assess how inacceptable the results are. Then try to estimate the quartiles range (75% - 25% of images).


Hysteresis Thresholding
========================================================
type:alert
For some images a single threshold does not work
- large structures are very clearly defined
- smaller structures are difficult to differentiated (see [partial volume effect](http://bit.ly/1mW7kdP))

[ImageJ Source](http://imagejdocu.tudor.lu/doku.php?id=plugin:segmentation:hysteresis_thresholding:start)

```{r, fig.cap="Bone Slice",fig.height=3}
bone.df<-im.to.df(png::readPNG("ext-figures/bonegfiltslice.png"))
ggplot(bone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=val))+
  labs(fill="Calcification Dens",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

```{r, fig.cap="Bone Slice Histogram",fig.height=3}
ggplot(bone.df,aes(x=val))+
  geom_histogram(aes(y=..density..),alpha=0.5)+
  geom_density()+
  labs(x="Calcification Dens")+
  theme_bw(20)
```

***

```{r, fig.cap="Bone Slice",fig.height=3}
thresh.fun<-function(x) {ifelse(x<0.05,"Air",ifelse(x<0.30,"Between","Bone"))}
bone.df$phase<-thresh.fun(bone.df$val)
ggplot(bone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=phase))+
  labs(fill="Phase",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

```{r, fig.cap="Bone Labeled Histogram",fig.height=3}
ggplot(bone.df,aes(x=val))+
  geom_histogram(aes(fill=phase),binwidth=0.02,alpha=0.5)+
  geom_density(aes(y=15000/1.5*..scaled..))+
  labs(x="Calcification Density (au)")+
  scale_y_sqrt()+#(c(0,20))+
  theme_bw(20)
```


More Complicated Images
===
As we briefly covered last time, many measurement types produce quite rich data.
$$ I(x,y) = \hat{f}(x,y) $$
```{r, fig.cap="",fig.height=3}
nx<-4
ny<-4
n.pi<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*n.pi*pi,
                     y=c(-ny:ny)/ny*n.pi*pi)

grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)),
              a=with(grad.im,sqrt(2/(abs(x)+0.5))),
               b=with(grad.im,0.5*sqrt(abs(x)+1)),
              th=0.5*runif(nrow(grad.im)),
              aiso=1,count=1)

create.ellipse.points<-function(x.off=0,y.off=0,a=1,b=NULL,th.off=0,th.max=2*pi,pts=36,...) {
  if (is.null(b)) b<-a
  th<-seq(0,th.max,length.out=pts)
  data.frame(x=a*cos(th.off)*cos(th)+b*sin(th.off)*sin(th)+x.off,
             y=-1*a*sin(th.off)*cos(th)+b*cos(th.off)*sin(th)+y.off,
             id=as.factor(paste(x.off,y.off,a,b,th.off,pts,sep=":")),...)
}
deform.ellipse.draw<-function(c.box) {
  create.ellipse.points(x.off=c.box$x[1],
                        y.off=c.box$y[1],
                        a=c.box$a[1],
                        b=c.box$b[1],
                        th.off=c.box$th[1],
                        col=c.box$col[1])                    
}

# normalize vector
tens.im<-ddply(grad.im,.(x,y),deform.ellipse.draw)

ggplot(tens.im,aes(x=x,y=y,group=as.factor(id),fill=col))+
  geom_polygon(color="black")+coord_fixed(ratio=1)+scale_fill_gradient(low="black",high="white")+guides(fill=F)+
  theme_bw(20)
```
Once the variable count is above 2, individual density functions and a series of cross plots are easier to interpret than some multidimensional density hypervolume.

***

```{r, fig.cap="Variable distributions",fig.height=4}
ggplot(grad.im)+
  geom_histogram(aes(x=a,fill="Width"),alpha=0.7)+
  geom_histogram(aes(x=b,fill="Height"),alpha=0.7)+
  geom_histogram(aes(x=th,fill="Orientation"),alpha=0.7)+
  geom_histogram(aes(x=col,fill="Color"),alpha=0.7)+
  guides(color=F)+labs(x="Value",fill="Variable")+
  theme_bw(15)
```

```{r, fig.cap="Intervariable correlation",fig.height=4}
plot(grad.im[,c("a","b","th","col")])
```

K-Means Clustering / Classification
===
- Automatic clustering of multidimensional data into groups based on a distance metric
- Fast and scalable to petabytes of data (Google, Facebook, Twitter, etc. use it regularly to classify customers, advertisements, queries)
- Segementation / Thresholding is really a classification task: given the gray value classify the pixel as either bone or air

K-Means Algorithm
===
type:alert
We give as an initial parameter the number of groups we want to find and possible a criteria for removing groups that are too similar
1. Randomly create center points (groups) in vector space
1. Assigns group to data point by the “closest” center
1. Recalculate centers from mean point in each group
1. Go back to step 2 until the groups stop changing

*** 

What vector space to we have?
- Sometimes represent physical locations (classify swiss people into cities)
- Can include intensity or color (K-means can be used as a thresholding technique when you give it image intensity as the vector and tell it to find two or more groups)
- Can also include orientation, shape, or in extreme cases full spectra (chemically sensitive imaging)

#### Note:  If you look for 2 groups you will almost always find two groups, whether or not they make any sense

K-Means Example
===
```{matlab}
objColor=kmeans(indata,2);
```
```{r, fig.cap="KMeans",fig.height=3}
grad.im$km.cluster<-kmeans(grad.im,2)$cluster
# normalize vector
tens.im<-ddply(grad.im,.(x,y),function(c.data) cbind(deform.ellipse.draw(c.data),
                                                     km.cluster=c.data[1,"km.cluster"]
                                                     )
               )

ggplot(tens.im,aes(x=x,y=y,group=as.factor(id),fill=as.factor(km.cluster)))+
  geom_polygon(color="black")+coord_fixed(ratio=1)+labs(fill="KMeans\nCluster")+
  theme_bw(20)
```
```{r, fig.cap="Variable distributions",fig.height=4}
splom(grad.im[,c("x","y","th","aiso")],groups=grad.im$km.cluster,pch=16)
```

***

Or just the orientation
```{matlab}
objColor=kmeans(indata(:,[aisoCol,thCol]),2);
```

```{r, fig.cap="KMeans",fig.height=3}
grad.im$km.cluster<-kmeans(grad.im[,c("th")],2)$cluster
# normalize vector
tens.im<-ddply(grad.im,.(x,y),function(c.data) cbind(deform.ellipse.draw(c.data),
                                                     km.cluster=c.data[1,"km.cluster"]
                                                     )
               )
ggplot(tens.im,aes(x=x,y=y,group=as.factor(id),fill=as.factor(km.cluster)))+
  geom_polygon(color="black")+coord_fixed(ratio=1)+labs(fill="KMeans\nCluster")+
  theme_bw(20)
```

```{r, fig.cap="Variable distributions",fig.height=4}
splom(grad.im[,c("x","y","th","aiso")],
      groups=grad.im$km.cluster,pch=16)
```

K-Means on Spectral Data
===
type:alert


Probabilistic Models of Segmentation
===
type:alert
A more general approach is to use a probabilistic model to segmentation. We start with our image $I(\vec{x}) \forall \vec{x}\in \mathbb{R}^N$ and we classify it into two phases $\alpha$ and $\beta$

$$P(\{\vec{x} , I(\vec{x})\}  | \alpha) \propto P(\alpha) + P(f(\vec{x}) | \alpha)+  P(\sum_{x^{\prime} \in \textrm{N}} f(\vec{x^{\prime}}) |  \alpha)$$
- $P(\{\vec{x} , f(\vec{x})\}  | \alpha)$ the probability a given pixel is in phase ph given we know it's position and value
- $P(\alpha)$ probability of any pixel in an image being part of the phase (expected volume fraction of that phase)
- $P(I(\vec{x}) | \alpha)$ probability adjustment based on knowing the value of f at the given point
- $P(f(\vec{x^{\prime}}) |  \alpha)$ are the collective probability adjustments based on knowing the value of a pixels neighbors

Fuzzy Classification
===
Fuzzy classification based on [Fuzzy logic](http://en.wikipedia.org/wiki/Fuzzy_logic) and [Fuzzy set theory](http://www.academia.edu/4978200/Applications_of_Fuzzy_Set_Theory_and_Fuzzy_Logic_in_Image_Processing) and is a general catagory for multi-value logic instead of simply __true__ and __false__ and can be used to build __IF__ and __THEN__ statements from our probabilistic models.

### Instead of

$$P(\{\vec{x} , I(\vec{x})\}  | \alpha) \propto P(\alpha) + P(f(\vec{x}) | \alpha)+$$
$$P(\sum_{x^{\prime} \in \textrm{N}} f(\vec{x^{\prime}}) |  \alpha)$$

***

### Clear simple rules
which encompass aspects of filtering, thresholding, and morphological operations
- __IF__ the intensity if dark ($<100$)
 - __AND__ a majority of the neighborhood ($\textrm{N}$) values are dark ($<100$)
- __THEN__ it is a cell


![Cell Colony](ext-figures/Cell_Colony.jpg)


Beyond
===
- A multitude of other techniques exist for classifying groups and courses in Data Science and Artificial Intelligence go into much greater details. 
- These techniques are generally underused because they are complicated to explain and robustly test and can arouse suspicion from reviewers. 
 - Because of their added complexity it is easier to manipulate these methods to get desired results from almost any dataset
 - But if the approach is based on a physical model of the images and the underyling system it is acceptable
- Additionally they usually require some degree of implementation (coding).




