```{r global_setup,  warning=FALSE, cache=FALSE,echo=FALSE,error=FALSE,results='hide'}
source("../common/slide_setup.R")
```

```{r script_setup, cache=F}
## The basic files and libraries needed for most presentations
# creates the libraries and common-functions sections
read_chunk("../common/utility_functions.R")
```
```{r libraries}
```
```{r common-functions}
```

Quantitative Big Imaging  
========================================================
author: Kevin Mader
date: 12 March 2015
width: 1440
height: 900
css: ../common/template.css
transition: rotate

ETHZ: 227-0966-00L
## Advanced Segmentation 


Course Outline
========================================================

```{r, results='asis'}
source('../common/schedule.R')
```


Literature / Useful References
========================================================

- Jean Claude, Morphometry with R
 - [Online](http://link.springer.com/book/10.1007%2F978-0-387-77789-4) through ETHZ
 - [Buy it](http://www.amazon.com/Morphometrics-R-Use-Julien-Claude/dp/038777789X)
- John C. Russ, “The Image Processing Handbook”,(Boca Raton, CRC Press)
 - Available [online](http://dx.doi.org/10.1201/9780203881095) within domain ethz.ch (or proxy.ethz.ch / public VPN) 
 
### Advanced Segmentation

- [Markov Random Fields for Image Processing Lecture](https://www.youtube.com/watch?v=vRN_j2j-CC4)
- [Markov Random Fields Chapter](http://www.cise.ufl.edu/~anand/pdf/bookchap.pdf)
- [Fuzzy set theory](http://www.academia.edu/4978200/Applications_of_Fuzzy_Set_Theory_and_Fuzzy_Logic_in_Image_Processing)
- [Superpixels](http://ivrg.epfl.ch/research/superpixels)

***

### Contouring
- [Active Contours / Snakes](http://link.springer.com/article/10.1007%2FBF00133570#page-1)



Lesson Outline
========================================================

- Motivation
 - Many Samples
 - Difficult Samples
 - Training / Learning
- Thresholding
 - Automated Methods
 - Hysteresis Method
- Feature Vectors
 - K-Means Clustering
 - Superpixels
 - Probabalistic Models
- Working with Segmented Images
 - Contouring
- Beyond
 - Fuzzy Models
 - Component Labeling


Previously on QBI
========================================================

- Image acquisition and representations
- Enhancement and noise reduction
- Understanding models and interpreting histograms
- Choosing a threshold
 - Examining more complicated, multivariate data sets
- Improving segementation with morphological operations
 - Filling holes
 - Connecting objects
 - Removing Noise
- Partial Volume Effect

Where segmentation fails: Inconsistent Illumination
========================================================

With inconsistent or every changing illumination it may not be possible to apply the same threshold to every image. 

```{r, fig.cap="Cell Colony with Different Illuminations",fig.height=7}
cellImage<-im.to.df(jpeg::readJPEG(qbi.file("Cell_Colony.jpg")))
max.il<-2.5
il.vals<-runif(9,min=1/max.il,max=max.il)
im.vals<-ldply(1:length(il.vals),function(il.idx,th.val=0.75)
  cbind(cellImage[,c("x","y")],
        val=cellImage$val*il.vals[il.idx],
        in.thresh=ifelse(cellImage$val*il.vals[il.idx]<th.val,"Cells","Background"),
        il.val=il.vals[il.idx],
        th.val=th.val,
        il.idx=il.idx
        ))
ggplot(im.vals,aes(x=x,y=y,fill=val))+
  geom_raster()+facet_wrap(~il.idx)+
  labs(fill="Intensity")+
  theme_bw(15)+coord_equal()
```

***

```{r, fig.cap="Different Illuminations with Constant Threshold",fig.height=8}

ggplot(subset(im.vals,in.thresh=="Cells"),aes(x=x,y=y))+
  geom_raster(fill="red")+facet_wrap(~il.idx)+
  labs(fill="Phase",title="Cell Phase")+
  theme_bw(20)+coord_equal()

```


Where segmentation fails: Canaliculi
========================================================
![Bone Slice](ext-figures/bonegfiltslice.png)

### Here is a bone slice

1. Find the larger cellular structures (osteocyte lacunae)
1. Find the small channels which connect them together

***

### The first task 
is easy using a threshold and size criteria (we know how big the cells should be)

### The second 
is much more difficult because the small channels having radii on the same order of the pixel size are obscured by partial volume effects and noise.

Where segmentation fails: Brain Cortex
========================================================
- The cortex is barely visible to the human eye
- Tiny structures hint at where cortex is located

```{r, fig.cap="Brain with Threshold",fig.height=5}
alz.df<-im.to.df(t(png::readPNG("ext-figures/cortex.png")))
ggplot(alz.df,aes(x=x,y=518-y))+
  geom_raster(aes(fill=val))+
  labs(fill="Electron Density",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

***

- A simple threshold is insufficient to finding the cortical structures
- Other filtering techniques are unlikely to magicially fix this problem
```{r, fig.cap="Brain with Threshold",fig.height=5}
ggplot(alz.df,aes(x=x,y=518-y))+
  geom_raster(aes(fill=cut_interval(val,4)))+
  labs(fill="Segmented Phases",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```


Automated Threshold Selection
========================================================
![Many possible automated techniques](ext-figures/automaticthresh.png)

***

Given that applying a threshold is such a common and signficant step, there have been many tools developed to automatically (unsupervised) perform it. A particularly important step in setups where images are rarely consistent such as outdoor imaging which has varying lighting (sun, clouds). The methods are based on several basic principles. 

Automated Methods
===

### Histogram-based methods
Just like we visually inspect a histogram an algorithm can examine the histogram and find local minimums between two peaks, maximum / minimum entropy and other factors

- Otsu, Isodata, Intermodes, etc

### Image based Methods
These look at the statistics of the thresheld image themselves (like entropy) to estimate the threshold  


### Results-based Methods
These search for a threshold which delivers the desired results in the final objects. For example if you know you have an image of cells and each cell is between 200-10000 pixels the algorithm runs thresholds until the objects are of the desired size
- More specific requirements need to be implemented manually

Histogram Methods
===

Taking a typical image of a bone slice, we can examine the variations in calcification density in the image

```{r, fig.cap="Bone Slice",fig.height=5}
bone.df<-im.to.df(png::readPNG("ext-figures/bonegfiltslice.png"))
ggplot(bone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=val))+
  labs(fill="Calcification Dens",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

***

We can see in the histogram that there are two peaks, one at 0 (no absorption / air) and one at 0.5 (stronger absorption / bone)

```{r, fig.cap="Bone Slice Histogram ",fig.height=5}
bhist<-ggplot(bone.df,aes(x=val))+
  geom_histogram(binwidth=0.05)+
  labs(x="Calcification Density")+
  theme_bw(20)
bhist
```

Histogram Methods
===
```{r, fig.cap="Bone Slice Histogram ",fig.height=5}
bhist
```

***

### Intermodes
 - Take the point between the two modes (peaks) in the histogram
 
### Otsu

Search and minimize intra-class (within) variance
$$\sigma^2_w(t)=\omega_{bg}(t)\sigma^2_{bg}(t)+\omega_{fg}(t)\sigma^2_{fg}(t)$$

### Isodata

- $\textrm{thresh}= \max(img)+\min(img)/2$
- _while_ the thresh is changing
 - $bg = img<\textrm{thresh}, obj = img>\textrm{thresh}$
 - $\textrm{thresh} = (\textrm{avg}(bg) + \textrm{avg}(obj))/2$


Fiji -> Adjust -> Auto Threshold
========================================================
There are many methods and they can be complicated to implement yourself. FIJI offers many of them as built in functions so you can automatically try all of them on your image
![Many possible automated techniques](ext-figures/tryall.png)

Pitfalls
===
While an incredibly useful tool, there are many potential pitfalls to these automated techniques. 

### Histogram-based

These methods are very sensitive to the distribution of pixels in your image and may work really well on images with equal amounts of each phase but work horribly on images which have very high amounts of one phase compared to the others

### Image-based

These methods are sensitive to noise and a large noise content in the image can change statistics like entropy significantly. 

### Results-based

These methods are inherently biased by the expectations you have. If you want to find objects between 200 and 1000 pixels you will, they just might not be anything meaningful.

Realistic Approaches for Dealing with these Shortcomings
===

Imaging science rarely represents the ideal world and will never be 100% perfect. At some point we need to write our master's thesis, defend, or publish a paper. These are approaches for more qualitative assessment we will later cover how to do this a bit more robustly with quantitative approaches

### Model-based

One approach is to try and simulate everything (including noise) as well as possible and to apply these techniques to many realizations of the same image and qualitatively keep track of how many of the results accurately identify your phase or not. Hint: >95% seems to convince most biologists

### Sample-based

Apply the methods to each sample and keep track of which threshold was used for each one. Go back and apply each threshold to each sample in the image and keep track of how many of them are correct enough to be used for further study.

### Worst-case Scenario

Come up with the worst-case scenario (noise, misalignment, etc) and assess how inacceptable the results are. Then try to estimate the quartiles range (75% - 25% of images).


Hysteresis Thresholding
========================================================
For some images a single threshold does not work
- large structures are very clearly defined
- smaller structures are difficult to differentiated (see [partial volume effect](http://bit.ly/1mW7kdP))

[ImageJ Source](http://imagejdocu.tudor.lu/doku.php?id=plugin:segmentation:hysteresis_thresholding:start)

```{r, fig.cap="Bone Slice",fig.height=3}
bone.df<-im.to.df(png::readPNG("ext-figures/bonegfiltslice.png"))
ggplot(bone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=val))+
  labs(fill="Calcification Dens",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

***

```{r, fig.cap="Bone Slice Histogram",fig.height=4}
ggplot(bone.df,aes(x=val))+
  geom_histogram(aes(y=..density..),alpha=0.5)+
  geom_density()+scale_y_sqrt()+
  labs(x="Calcification Dens")+
  theme_bw(20)
```

```{r, fig.cap="Bone Labeled Histogram",fig.height=4}
thresh.fun<-function(x) {ifelse(x<0.01,"Air",ifelse(x<0.30,"Between","Bone"))}
bone.df$phase<-thresh.fun(bone.df$val)
ggplot(bone.df,aes(x=val))+
  geom_histogram(aes(fill=phase),binwidth=0.02,alpha=0.5)+
  geom_density(aes(y=15000/1.5*..scaled..))+
  labs(x="Calcification Density (au)")+
  scale_y_sqrt()+#(c(0,20))+
  theme_bw(20)
```


Hysteresis Thresholding
========================================================
Comparing the original image with the three phases

```{r, fig.cap="Bone Slice",fig.height=7}
ggplot(bone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=val))+
  labs(fill="Calcification Dens",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

***

```{r, fig.cap="Bone Slice",fig.height=8}
ggplot(bone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=phase))+
  labs(fill="Phase",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```



Hysteresis Thresholding: Reducing Pixels
========================================================

Now we apply two important steps. The first is to remove the objects which are not cells (too small) using an opening operation.
```{r, fig.cap="Bone Slice",fig.height=7}
air.im<-df.to.im(cbind(bone.df,isair=bone.df$phase=="Air"),"isair")
air.df<-im.to.df(opening(air.im,makeBrush(5,"disc")))
names(air.df)[3]<-"stillair"
nbone.df<-merge(air.df,bone.df)
ggplot(nbone.df,aes(x=x,y=y))+
  geom_raster(aes(fill=phase,alpha=stillair))+
  labs(fill="Phase",y="y",x="x",title="After Opening")+
  coord_equal()+guides(alpha=F)+
  theme_bw(20)
# if its air make sure its still air otherwise demote it to between, 
# if its not air leave it alone
nbone.df$phase<-ifelse(nbone.df$phase=="Air",
       ifelse(nbone.df$stillair>0,"Air","Between"),
       nbone.df$phase)
```

***

The second step to keep the _between_ pixels which are connected (by looking again at a neighborhood $\mathcal{N}$) to the _air_ voxels and ignore the other ones. This goes back to our original supposition that the smaller structures are connected to the larger structures

```{r, fig.cap="Bone Slice",fig.height=5}
# incredibly low performance implementation (please do not copy)
bone.idf<-nbone.df
bet.pts<-nbone.df
# run while there is still new air being created
while(nrow(subset(bet.pts,phase=="Air"))>0) {
  air.pts<-subset(bone.idf,phase=="Air")[,c("x","y")]
  bone.pts<-subset(bone.idf,phase=="Bone")[,c("x","y")]
  bet.pts<-ddply(subset(bone.idf,phase=="Between"),.(x,y),function(in.pixel.lst) {
    in.pixel<-in.pixel.lst[1,]
    data.frame(phase=ifelse(min(with(air.pts,(in.pixel$x-x)^2+(in.pixel$y-y)^2))<=1,
         "Air",
         "Between"))
  })
  bone.idf<-rbind(bet.pts,
                  cbind(air.pts,phase="Air"),
                  cbind(bone.pts,phase="Bone"))
  print(nrow(subset(bet.pts,phase=="Air")))
}
ggplot(bone.idf,aes(x=x,y=y))+
  geom_raster(aes(fill=phase))+
  labs(fill="Phase",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```


More Complicated Images
===
As we briefly covered last time, many measurement techniques produce quite rich data. 
- Digital cameras produce 3 channels of color for each pixel (rather than just one intensity)
- MRI produces dozens of pieces of information for every voxel which are used when examining different _contrasts_ in the system.
- Raman-shift imaging produces an entire spectrum for each pixel
- Coherent diffraction techniques produce 2- (sometimes 3) diffraction patterns for each point.
$$ I(x,y) = \hat{f}(x,y) $$

***

```{r, fig.cap="",fig.height=7}
nx<-4
ny<-4
n.pi<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*n.pi*pi,
                     y=c(-ny:ny)/ny*n.pi*pi)

grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)),
              a=with(grad.im,sqrt(2/(abs(x)+0.5))),
               b=with(grad.im,0.5*sqrt(abs(x)+1)),
              th=0.5*runif(nrow(grad.im)),
              aiso=1,count=1)

create.ellipse.points<-function(x.off=0,y.off=0,a=1,b=NULL,th.off=0,th.max=2*pi,pts=36,...) {
  if (is.null(b)) b<-a
  th<-seq(0,th.max,length.out=pts)
  data.frame(x=a*cos(th.off)*cos(th)+b*sin(th.off)*sin(th)+x.off,
             y=-1*a*sin(th.off)*cos(th)+b*cos(th.off)*sin(th)+y.off,
             id=as.factor(paste(x.off,y.off,a,b,th.off,pts,sep=":")),...)
}
deform.ellipse.draw<-function(c.box) {
  create.ellipse.points(x.off=c.box$x[1],
                        y.off=c.box$y[1],
                        a=c.box$a[1],
                        b=c.box$b[1],
                        th.off=c.box$th[1],
                        col=c.box$col[1])                    
}

# normalize vector
tens.im<-ddply(grad.im,.(x,y),deform.ellipse.draw)

ggplot(tens.im,aes(x=x,y=y,group=as.factor(id),fill=col))+
  geom_polygon(color="black")+coord_fixed(ratio=1)+scale_fill_gradient(low="black",high="white")+guides(fill=F)+
  theme_bw(20)
```

Feature Vectors
===

__A pairing between spatial information (position) and some other kind of information (value).__
$$ \vec{x} \rightarrow \vec{f} $$

We are used to seeing images in a grid format where the position indicates the row and column in the grid and the intensity (absorption, reflection, tip deflection, etc) is shown as a different color

```{r makebasicimage}
basic.image<-im.to.df(matrix(round(runif(5*5,0,100)),nrow=5))
names(basic.image)[3]<-"Intensity"
```

```{r, fig.height=5}
simple.image<-ggplot(basic.image,aes(x,y,fill=Intensity))+
  geom_tile(color="black")+
  geom_text(aes(label=paste("(",x,",",y,")\n",round(Intensity))))+
  coord_equal()+
  theme_bw(15)

simple.image
```

***

The alternative form for this image is as a list of positions and a corresponding value

$$ \hat{I} = (\vec{x},\vec{f}) $$

```{r, results='asis'}
kable(head(basic.image))
```

This representation can be called the __feature vector__ and in this case it only has Intensity

Why Feature Vectors
===

If we use feature vectors to describe our image, we are no longer to worrying about how the images will be displayed, and can focus on the segmentation/thresholding problem from a classification rather than a image-processing stand point. 

### Example
So we have an image of a cell and we want to identify the membrane (the ring) from the nucleus (the point in the middle).

```{r makeringimage}
ring.image<-mutate(
  expand.grid(x=c(-10:10),y=c(-10:10)),
  Intensity = abs(cos(sqrt(x^2+y^2)/15*6.28))
  )
```

```{r, fig.height=5}
simple.image<-ggplot(ring.image,aes(x,y,fill=Intensity))+
  geom_tile(color="black")+
  coord_equal()+
  theme_bw(15)

simple.image
```

***

A simple threshold doesn't work because we identify the point in the middle as well. We could try to use morphological tricks to get rid of the point in the middle, or we could better tune our segmentation to the ring structure.

```{r, fig.height=5}
ggplot(ring.image,aes(x,y,fill=Intensity))+
  geom_tile(color="black")+
  geom_tile(data=subset(ring.image,Intensity>0.75),aes(color="Threshold"),fill="red",alpha=0.5)+
  coord_equal()+
  labs(color="")+
  theme_bw(15)
```

Adding a new feature
===

In this case we add a very simple feature to the image, the distance from the center of the image (distance).
```{r ringadddist}
ring.image.dist<-ddply(ring.image,.(x,y),function(in.pts) {
  in.pts$Distance<-with(in.pts,sqrt(
      min(
        x^2+y^2
      )
    ))
  in.pts
})
```

```{r, fig.height=5}
ggplot(ring.image.dist,aes(x,y,fill=Distance))+
  geom_tile(color="black")+
  coord_equal()+
  scale_fill_gradientn(colours=rainbow(5))+
  theme_bw(15)
```

```{r, results='asis'}
kable(head(ring.image.dist))
```

***

We now have a more complicated image, which we can't as easily visualize, but we can incorporate these two pieces of information together. 

```{r}
ggplot(ring.image.dist,aes(y=Distance,x=Intensity))+
  geom_density2d()+
  geom_point(aes(color=Distance,size=Intensity))+
  scale_color_gradientn(colours=rainbow(5))+
  labs(color="Distance",size="Intensity")+
  theme_bw(20)
```


Applying two criteria
===

Now instead of trying to find the intensity for the ring, we can combine density and distance to identify it 

$$ iff (5<\textrm{Distance}<10 \\ \& 0.5<\textrm{Intensity}>1.0) $$

```{r}
ggplot(ring.image.dist,aes(y=Distance,x=Intensity))+
  geom_density2d(aes(color="Density"))+
  geom_point()+
  geom_rect(aes(color="Threshold"),xmin=0.5,xmax=1,ymin=5,ymax=10,fill=NA)+
  labs(color="")+
  theme_bw(20)
```

***


```{r, fig.height=5}
ring.image.seg<-mutate(ring.image.dist,
                       Segmented = Intensity>0.5 & Distance>5 & Distance<10)
ggplot(ring.image,aes(x,y,fill=Intensity))+
  geom_tile(color="black")+
  geom_tile(data=subset(ring.image.seg,Segmented),
            aes(color="Threshold"),fill="red",alpha=0.5)+
  coord_equal()+
  labs(color="")+
  theme_bw(15)
```

Common Features
===
The distance while illustrative is not a commonly used features, more common various filters applied to the image
- Gaussian Filter (information on the values of the surrounding pixels)
- Sobel / Canny Edge Detection (information on edges in the vicinity)
- Entroy (information on variability in vicinity)
```{r makefeaturevecimage}
ring.array<-df.to.im(ring.image,val.col="Intensity")
sobel.image<-im.to.df(imgSobel(ring.array),out.col="Sobel")
gauss.image<-im.to.df(gblur(ring.array,0.5),out.col="Gaussian")
merged.ring.image<-merge(
  merge(
        mutate(ring.image.seg,x=x+11,y=y+11,Distance=Distance/10),
        sobel.image),
        gauss.image
        )
```

```{r, results='asis'}
kable(head(merged.ring.image[,c("x","y","Intensity","Sobel","Gaussian")]),digits=2)
```

***

```{r, fig.height=8}
mfeat.vec<-melt(merged.ring.image,id.vars=c("x","y","Segmented","Distance"))
ggplot(mfeat.vec,
       aes(x=x,y=y,fill=value))+
  geom_tile(size=1,alpha=0.75)+
  scale_fill_gradientn(colours=rainbow(5))+
  coord_equal()+
  labs(fill="")+
  facet_grid(variable~.)+
  theme_bw(20)
```

Analyzing the feature vector
===

The distributions of the features appear very different and can thus likely be used for identifying different parts of the images. 

```{r}
ggplot(mfeat.vec,aes(x=value,color=variable))+
  geom_density()+
  scale_y_sqrt()+
  labs(x="Feature Value",color="Feature")+
  theme_bw(20)
```

***

Combine this with our _a priori_ information (called supervised analysis)

```{r, fig.height=3}
ggplot(mutate(mfeat.vec,Structure=ifelse(Segmented,"Ring","Background")),
       aes(x=value,color=Structure))+
  geom_density()+
  labs(x="Feature Value",color="Structure")+
  facet_grid(variable~.,scales="free")+
  theme_bw(12)
```

```{r fig.height=5}
splom(merged.ring.image[,c("Intensity","Sobel","Gaussian")],groups=merged.ring.image$Segmented,pch=16)
```


K-Means Clustering / Classification (Unsupervised)
===
- Automatic clustering of multidimensional data into groups based on a distance metric
- Fast and scalable to petabytes of data (Google, Facebook, Twitter, etc. use it regularly to classify customers, advertisements, queries)
- __Input__ = feature vectors, distance metric, number of groups
- __Output__ = a classification for each feature vector to a group


K-Means Example
===

### Input
- Feature vectors ($\vec{v}$)
```{r, results='asis'}
kable(row.names=T,head(merged.ring.image[,c("x","y","Intensity","Sobel","Gaussian")]),digits=2)
```

- Distance metric 
$$ D_{ij}=||\vec{v}_i-\vec{v}_j|| $$

- Group Count ($N=2$)


***

$$\downarrow$$
### Output

- Group 1
```{r, results='asis'}
kable(row.names=T,merged.ring.image[c(20:24),c("x","y","Intensity","Sobel","Gaussian")],digits=2)
```

- Group 2
```{r, results='asis'}
kable(row.names=T,merged.ring.image[c(100:104),c("x","y","Intensity","Sobel","Gaussian")],digits=2)
```

K-Means Algorithm
===
We give as an initial parameter the number of groups we want to find and possible a criteria for removing groups that are too similar

1. Randomly create center points (groups) in vector space
1. Assigns group to data point by the “closest” center
1. Recalculate centers from mean point in each group
1. Go back to step 2 until the groups stop changing

*** 

What vector space to we have?
- Sometimes represent physical locations (classify swiss people into cities)
- Can include intensity or color (K-means can be used as a thresholding technique when you give it image intensity as the vector and tell it to find two or more groups)
- Can also include orientation, shape, or in extreme cases full spectra (chemically sensitive imaging)

#### Note:  If you look for N groups you will almost always find N groups with K-Means, whether or not they make any sense

K-Means Example
===
Continuing with our previous image and applying K-means to the Intensity, Sobel and Gaussian channels looking for 2 groups we find

```{r, fig.cap="KMeans",fig.height=4}
sring.image<-merged.ring.image[,c("x","y","Intensity","Sobel","Gaussian")]
sring.image$km.cluster<-kmeans(sring.image[,c("Intensity","Sobel","Gaussian")],2)$cluster
sring.vec<-melt(sring.image,id.vars=c("x","y","km.cluster"))
ggplot(sring.vec,
       aes(x=x,y=y,fill=value,color=as.factor(km.cluster)))+
  geom_tile(size=0.75,alpha=0.75)+
  #scale_fill_gradientn(colours=rainbow(5))+
  coord_equal()+
  labs(fill="",color="Cluster")+
  facet_grid(~variable)+
  theme_bw(10)
```

```{r, fig.cap="Variable distributions",fig.height=4}
splom(sring.image[,c("Intensity","Sobel","Gaussian")],groups=sring.image$km.cluster,pch=16)
```

***

Looking for 5 groups
```{r, fig.cap="KMeans",fig.height=4}
sring.image$km.cluster<-kmeans(sring.image[,c("Intensity","Sobel","Gaussian")],5)$cluster
sring.vec<-melt(sring.image,id.vars=c("x","y","km.cluster"))
ggplot(sring.vec,
       aes(x=x,y=y,fill=value,color=as.factor(km.cluster)))+
  geom_tile(size=0.75,alpha=0.75)+
  #scale_fill_gradientn(colours=rainbow(5))+
  coord_equal()+
  labs(fill="",color="Cluster")+
  facet_grid(~variable)+
  theme_bw(10)
```

```{r, fig.cap="Variable distributions",fig.height=4}
splom(sring.image[,c("Intensity","Sobel","Gaussian")],groups=sring.image$km.cluster,pch=16)
```

Changing the feature vector
===
Including the position in the features as well

```{r, fig.cap="KMeans",fig.height=4, fig.height=9}
sring.image$km.cluster<-kmeans(sring.image[,c("x","y","Intensity","Sobel","Gaussian")],5)$cluster
sring.vec<-melt(sring.image,id.vars=c("x","y","km.cluster"))
ggplot(sring.vec,
       aes(x=x,y=y,fill=value,color=as.factor(km.cluster)))+
  geom_tile(size=0.75,alpha=0.75)+
  #scale_fill_gradientn(colours=rainbow(5))+
  coord_equal()+
  labs(fill="",color="Cluster")+
  facet_grid(variable~.)+
  theme_bw(10)
```

***

```{r, fig.cap="Variable distributions",fig.height=8}
splom(sring.image[,c("x","y","Intensity","Sobel","Gaussian")],groups=sring.image$km.cluster,pch=16)
```

Rescaling components 
===
Since the distance is currently calculated by $||\vec{v}_i-\vec{v}_j||$ and the values for the position is much larger than the values for the _Intensity_, _Sobel_ or _Gaussian_ they need to be rescaled so they all fit on the same axis 
$$\vec{v} = \left\{\frac{x}{10}, \frac{y}{10}, \textrm{Intensity},\textrm{Sobel},\textrm{Gaussian}\right\}$$

```{r, fig.cap="KMeans",fig.height=6}
sring.image$km.cluster<-kmeans(mutate(
  sring.image[,c("x","y","Intensity","Sobel","Gaussian")],
  x=x/20,y=y/20)
                               ,5)$cluster

sring.vec<-melt(sring.image,id.vars=c("x","y","km.cluster"))
ggplot(sring.vec,
       aes(x=x,y=y,fill=value,color=as.factor(km.cluster)))+
  geom_tile(size=0.75,alpha=0.75)+
  #scale_fill_gradientn(colours=rainbow(5))+
  coord_equal()+
  labs(fill="",color="Cluster")+
  facet_grid(~variable)+
  theme_bw(10)
```

***

```{r, fig.cap="Variable distributions",fig.height=8}
splom(sring.image[,c("x","y","Intensity","Sobel","Gaussian")],groups=sring.image$km.cluster,pch=16)
```

Super-pixels
===
An approach for simplifying images by performing a clustering and forming super-pixels from groups of similar pixels.

```{r}
shale.array<-readTiff(qbi.file("shale-slice.tiff"))
shale.image<-im.to.df(shale.array[,,1],out.col="Intensity")
ggplot(shale.image,aes(x,y,fill=Intensity))+
  geom_tile()+
  coord_equal()+
  labs(fill="")+
  theme_bw(10)
  
```

***

```{r}
pos.scale<-5
shale.kmeans.data<-mutate(
  shale.image[,c("x","y","Intensity")],
  x=x/pos.scale,y=y/pos.scale)
# evenly spaced grid
grid.size<-40
grid.center<-round(grid.size/2)
shale.superpixels.centers<-subset(shale.kmeans.data, 
                                  x%%grid.size==grid.center & x%%grid.size==grid.center)
# not the real super pixels algorithm but close enough, see paper and websites
# http://www.kev-smith.com/papers/SLIC_Superpixels.pdf
# http://ivrg.epfl.ch/research/superpixels
shale.kmeans<-kmeans(shale.kmeans.data,
                               centers=shale.superpixels.centers,
                               iter.max=50
  )
shale.image$km.cluster<-shale.kmeans$cluster
```


```{r, fig.cap="KMeans",fig.height=6}
ggplot(shale.image,
       aes(x=x,y=y,alpha=Intensity))+
  geom_tile(aes(fill=as.factor(km.cluster)),size=0)+#,alpha=0.75)+
  scale_alpha_continuous(range=c(0.5,1))+
  guides(fill=F)+
  coord_equal()+
  labs(fill="")+
  theme_bw(10)

```

Why use superpixels
===

Drastically reduced data size, serves as an initial segmentation showing spatially meaningful groups
```{r}

shale.centers<-mutate(as.data.frame(shale.kmeans$centers),x=pos.scale*x,y=pos.scale*y)
ggplot(shale.centers,
       aes(x,y,color=Intensity))+
  geom_point(size=3)+
  scale_color_gradientn(colours=rainbow(5))+
  labs(x="X",y="Y")+
  coord_equal()+
  theme_bw(20)
```

***

```{r, fig.height=4}

ggplot(shale.centers,
       aes(x=Intensity))+
  geom_vline(aes(xintercept=Intensity),alpha=0.02)+
  geom_density(aes(y=..count..))+
  geom_vline(aes(color="Threshold"),color="red",xintercept=c(130,180))+
  labs(y="Number of Superpixels")+
  theme_bw(20)
```

Segment the superpixels and apply them to the whole image (only a fraction of the data and much smaller datasets)

```{r}

shale.centers<-mutate(shale.centers,
                      cluster=1:nrow(shale.centers),
                      group=as.factor(ifelse(Intensity<130,"Dark",
                                   ifelse(Intensity<180,"Medium","Light")))
                      )
grp.image<-merge(shale.image,shale.centers[,c("cluster","group")],by.x="km.cluster",by.y="cluster")
```

```{r, fig.height=4}

ggplot(grp.image,
       aes(x=x,y=y,alpha=Intensity))+
  geom_tile(aes(fill=as.factor(group)),size=0)+#,alpha=0.75)+
  scale_alpha_continuous(range=c(0.5,1))+
  coord_equal()+
  labs(fill="")+
  theme_bw(10)
```

Superpixels vs Standard Segmentation
===

### Superpixels (0.06% of the original)

```{r, fig.height=9}
ggplot(grp.image,
       aes(x=x,y=y,alpha=Intensity))+
  geom_tile(aes(fill=as.factor(group)),size=0)+#,alpha=0.75)+
  scale_alpha_continuous(range=c(0.5,1))+
  coord_equal()+
  labs(fill="")+
  theme_bw(10)

```

***

### Original

```{r, fig.height=9}

ggplot(
  mutate(shale.image,group=as.factor(ifelse(Intensity<130,"Dark",
                                   ifelse(Intensity<180,"Medium","Light")))),
       aes(x=x,y=y,alpha=Intensity))+
  geom_tile(aes(fill=as.factor(group)),size=0)+#,alpha=0.75)+
  scale_alpha_continuous(range=c(0.5,1))+
  coord_equal()+
  labs(fill="")+
  theme_bw(10)
```

Probabilistic Models of Segmentation
===
A more general approach is to use a probabilistic model to segmentation. We start with our image $I(\vec{x}) \forall \vec{x}\in \mathbb{R}^N$ and we classify it into two phases $\alpha$ and $\beta$

$$P(\{\vec{x} , I(\vec{x})\}  | \alpha) \propto P(\alpha) + P(I(\vec{x}) | \alpha)+  P(\sum_{x^{\prime} \in \mathcal{N}} I(\vec{x^{\prime}}) |  \alpha)$$
- $P(\{\vec{x} , f(\vec{x})\}  | \alpha)$ the probability a given pixel is in phase $\alpha$ given we know it's position and value (what we are trying to estimate)
- $P(\alpha)$ probability of any pixel in an image being part of the phase (expected volume fraction of that phase)
- $P(I(\vec{x}) | \alpha)$ probability adjustment based on knowing the value of $I$ at the given point (standard threshold)
- $P(f(\vec{x^{\prime}}) |  \alpha)$ are the collective probability adjustments based on knowing the value of a pixels neighbors (very simple version of [Markov Random Field](http://en.wikipedia.org/wiki/Markov_random_field) approaches)



Contouring
===

Expanding on the hole filling issues examined before, a general problem in imaging is identifying regions of interest with in an image. 

- For samples like brains it is done to identify different regions of the brain which are responsible for different functions. 

- In material science it might be done to identify a portion of the sample being heated or understress. 

- There are a number of approaches depending on the clarity of the data and the 


Convex Hull Approach
===
takes all of the points in a given slice or volume and finds the smallest convex 2D area or 3D volume (respectively) which encloses all of those points.

```{r}
test.im<-function(n) mutate(
  data.frame(th=c(0:200)/200.0*2*pi),
  r=cos(th*n),
  x=r*cos(th),
  y=r*sin(th)
  )
pthull<-function(pts,x.col="x",y.col="y") {
  pts.hull<-chull(pts[,c(x.col,y.col)])
  pts[c(pts.hull,pts.hull[1]),c(x.col,y.col)]
}
test.imgs<-ldply(c(1:6),function(n) {
  tdata<-test.im(n)[,c("x","y")]
  cbind(rbind(cbind(tdata,src="pts"),
        cbind(pthull(tdata),src="hull")),n=n)
})

ggplot(subset(test.imgs,src=="pts"),aes(x,y))+
  geom_polygon(data=subset(test.imgs,src=="hull"),aes(fill="convex\nhull"),alpha=0.5)+
  geom_point()+
  labs(fill="")+
  facet_wrap(~n)+
  theme_bw(20)
```

***

Depending on the type of sample the convex hull can make sense for filling in the gaps and defining the boundaries for a sample.
```{r}
test.img<-subset(test.imgs,n==2 & src=="pts")[,c("x","y")]
ggplot(test.img,aes(x,y))+
  geom_polygon(data=pthull(test.img),aes(fill="convex\nhull"),alpha=0.5)+
  geom_point()+
  labs(fill="")+
  theme_bw(20)
```

The critical short coming is it is very sensitive to single outlier points. 
 
```{r}
test.img<-rbind(subset(test.imgs,n==2 & src=="pts")[,c("x","y")],data.frame(x=-1,y=-1))
ggplot(test.img,aes(x,y))+
  geom_polygon(data=pthull(test.img),aes(fill="convex\nhull"),alpha=0.5)+
  geom_point()+
  labs(fill="")+
  theme_bw(20)
```

Convex Hull Example
===


The convex hull very closely matches the area we would define as 'bone' without requiring any parameter adjustment, resolution specific adjustments, or extensive image-processing, for such a sample a convex hull is usually sufficient.

```{r, fig.cap="Cortical Segment Convex Hull",fig.height=7}
cortbone.im<-imagedata(t(png::readPNG(qbi.file("bone-section.png"))[,,1]),"grey")
cortbone.df<-im.to.df(cortbone.im)
# calculate convex hull
cortbone.chull<-chull(subset(cortbone.df,val>0.5)[,c("x","y")])
cortbone.chull<-c(cortbone.chull,cortbone.chull[1])
cortbone.chull<-subset(cortbone.df,val>0.5)[cortbone.chull,c("x","y")]
ggplot(subset(cortbone.df,val>0.5),aes(x=x,y=518-y))+
  geom_polygon(data=cortbone.chull,aes(fill="convex hull"),alpha=0.5)+
  geom_raster(aes(fill="original"),alpha=0.8)+
  labs(fill="Image",y="y",x="x",title="Convex Hull Creation")+
  coord_equal()+
  theme_bw(20)
```

***


Here is an example of the convex hull applied to a region of a cortical bone sample. The green shows the bone and the red shows the convex hull. Compared to a visual inspection, the convex hull overestimates the bone area as we probably would not associate the region where the bone curves to the right with 'bone area'

```{r, fig.cap="Cortical Segment Convex Hull",fig.height=7}
cortbone.im<-imagedata(t(png::readPNG(qbi.file("bone.png"))),"grey")
cortbone.df<-im.to.df(cortbone.im)
# calculate convex hull
cortbone.chull<-chull(subset(cortbone.df,val<1)[,c("x","y")])
cortbone.chull<-c(cortbone.chull,cortbone.chull[1])
cortbone.chull<-subset(cortbone.df,val<1)[cortbone.chull,c("x","y")]
ggplot(subset(cortbone.df,val<1),aes(x=x,y=518-y))+
  geom_polygon(data=cortbone.chull,aes(fill="convex hull"),alpha=0.5)+
  geom_raster(aes(fill="original"),alpha=0.8)+
  labs(fill="Image",y="y",x="x",title="Convex Hull Creation")+
  coord_equal()+
  theme_bw(20)
```

***



Rubber Band
===
```{r rubber_band_fcn}
## the rubber band function to fit a boundary around the curve
rubber.band.data<-function(raw.df,binning.pts=10,eval.fun=max) {
  in.df<-raw.df
  # calculate center of mass
  com.val<-colMeans(in.df)
  # add polar coordinates
  in.df$r<-with(in.df,sqrt((x-com.val["x"])^2+(y-com.val["y"])^2))
  in.df$theta<-with(in.df,atan2(y-com.val["y"],x-com.val["x"]))
  # create a maximum path
  outer.path<-ddply.cutcols(in.df,.(cut_interval(theta,binning.pts)),function(c.section) data.frame(r=eval.fun(c.section$r)))
  outer.path$x<-with(outer.path,r*cos(theta)+com.val["x"])
  outer.path$y<-with(outer.path,r*sin(theta)+com.val["y"])
  outer.path
}
```
Useful for a variety of samples (needn't be radially symmetric) and offers more flexibility in step size, smoothing function etc than convex hull. 

1. Calculates the center of mass.
1. Transforms sample into Polar Coordinates 
1. Calculates a piecewise linear fit $r=f(\theta)$

```{r, fig.cap="First Rubber Bands",fig.height=5}

ggplot(subset(cortbone.df,val<1),aes(x=x,y=518-y))+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),9),aes(fill="rubber band   9pts"),alpha=0.5)+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),36),aes(fill="rubber band  36pts"),alpha=0.5)+
  geom_raster(aes(fill="original"),alpha=0.8)+
  labs(fill="Image",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

***

```{r, fig.cap="Better Rubber Bands",fig.height=4}

ggplot(subset(cortbone.df,val<1),aes(x=x,y=518-y))+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),90),aes(fill="rubber band  90pts"),alpha=0.5)+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),180),aes(fill="rubber band 180pts"),alpha=0.5)+
  geom_raster(aes(fill="original"),alpha=0.8)+
  labs(fill="Image",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

```{r, fig.cap="In Detail",fig.height=4}
ggplot(subset(cortbone.df,val<1),aes(x=x,y=518-y))+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),180),aes(fill="rubber band 180pts"),alpha=0.5)+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),720),aes(fill="rubber band 720pts"),alpha=0.5)+
  geom_raster(aes(fill="original"),alpha=0.8)+
  labs(fill="Image",y="y",x="x")+
  coord_equal()+xlim(50,150)+ylim(-100,50)+
  theme_bw(20)
```


Rubber Band: More flexible constraints
===

If we use quartiles or the average instead of the maximum value we can make the method less sensitive to outlier pixels

```{r, fig.cap="In Detail",fig.height=4}
ggplot(subset(cortbone.df,val<1),aes(x=x,y=518-y))+
  geom_raster(aes(fill="original"),alpha=0.8)+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),90,eval.fun=mean),
               aes(fill="rubber band mean value"),alpha=0.5)+
  geom_polygon(data=rubber.band.data(subset(cortbone.df,val<1),90,
                                     eval.fun=function(x) quantile(x,0.99)),
               aes(fill="rubber band upper 99%"),alpha=0.5)+

  labs(fill="Image",y="y",x="x")+
  coord_equal()+
  theme_bw(20)
```

Contouring: Manual - Guided Methods
===

Many forms of guided methods exist, the most popular is known simply as the _Magnetic Lasso_ in Adobe Photoshop ([video](http://people.ee.ethz.ch/~maderk/videos/MagneticLasso.swf)).

The basic principal behind many of these methods is to optimize a set of user given points based on local edge-like information in the image. In the brain cortex example, this is the small gradients in the gray values which our eyes naturally seperate out as an edge but which have many gaps and discontinuities. 

[Active Contours / Snakes](http://link.springer.com/article/10.1007%2FBF00133570#page-1)




Beyond
===
- A multitude of other techniques exist for classifying groups and courses in Data Science and Artificial Intelligence go into much greater details. 
- These techniques are generally underused because they are complicated to explain and robustly test and can arouse suspicion from reviewers. 
 - Because of their added complexity it is easier to manipulate these methods to get desired results from almost any dataset
 - But if the approach is based on a physical model of the images and the underyling system it is acceptable
- Additionally they usually require some degree of implementation (coding).

Fuzzy Classification
===
Fuzzy classification based on [Fuzzy logic](http://en.wikipedia.org/wiki/Fuzzy_logic) and [Fuzzy set theory](http://www.academia.edu/4978200/Applications_of_Fuzzy_Set_Theory_and_Fuzzy_Logic_in_Image_Processing) and is a general catagory for multi-value logic instead of simply __true__ and __false__ and can be used to build __IF__ and __THEN__ statements from our probabilistic models.

### Instead of

$$P(\{\vec{x} , I(\vec{x})\}  | \alpha) \propto P(\alpha) + P(I(\vec{x}) | \alpha)+$$
$$P(\sum_{x^{\prime} \in \mathcal{N}} I(\vec{x^{\prime}}) |  \alpha)$$

***

### Clear simple rules
which encompass aspects of filtering, thresholding, and morphological operations
- __IF__ the intensity if dark ($<100$)
 - __AND__ a majority of the neighborhood ($\mathcal{N}$) values are dark ($<100$)
- __THEN__ it is a cell


![Cell Colony](ext-figures/Cell_Colony.jpg)




