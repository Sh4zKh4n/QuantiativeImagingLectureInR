```{r global_setup, echo=FALSE, warning=FALSE, cache=FALSE}
require(knitr)
opts_chunk$set(dpi=150,cache=T,results='hide',warning=F,fig.align='center',echo=F,fig.height=5) #dev="CairoPNG"
require(ggplot2)
require(plyr)
require(grid) # contains the arrow function
require(biOps)
# functions for converting images back and forth
im.to.df<-function(in.img) {
    out.im<-expand.grid(x=1:nrow(in.img),y=1:ncol(in.img))
    out.im$val<-as.vector(in.img)
    out.im
}
df.to.im<-function(in.df,val.col="val",inv=F) {
  in.vals<-in.df[[val.col]]
  if(class(in.vals[1])=="logical") in.vals<-as.integer(in.vals*255)
  if(inv) in.vals<-255-in.vals
  out.mat<-matrix(in.vals,nrow=length(unique(in.df$x)),byrow=F)
  attr(out.mat,"type")<-"grey"
  out.mat
}
```

Quantitative Big Imaging  
========================================================
author: Kevin Mader
date: 6 March 2014
width: 1440
height: 900
transition: rotate

## Basic Segmentation and Discrete Binary Structures


Course Outline
========================================================
- 20th February - Introductory Lecture
- 27th February - Filtering and Image Enhancement (A. Kaestner)
- 6th March - **Basic Segmentation, Discrete Binary Structures**
- 13th March - Advanced Segmentation
- 20th March - Analyzing Single Objects
- 27th March -  Analyzing Complex Objects
- 3rd April -  Spatial Distribution
- 10th April -  Statistics and Reproducibility
- 17th April - Dynamic Experiments
- 8th May - Big Data
- 15th May - Guest Lecture - Applications in Material Science
- 22th May - Project Presentations

Literature / Useful References
========================================================
- Jean Claude, Morphometry with R
 - Online through ETHZ at http://link.springer.com/book/10.1007%2F978-0-387-77789-4
 - Buy it at: http://www.amazon.com/Morphometrics-R-Use-Julien-Claude/dp/038777789X
- John C. Russ, “The Image Processing Handbook”,(Boca Raton, CRC Press)
 - Available online within domain ethz.ch (or proxy.ethz.ch / public VPN) http://dx.doi.org/10.1201/9780203881095

Motivation:  Why do we do imaging experiments?
========================================================
#incremental: true

- To get an idea of what is going on
- To test a hypothesis
 - Does temperature affect bubble size?
 - Is this gene important for cell shape and thus mechanosensation in bone?
 - Does higher canal volume make bones weaker?
 - Does the granule shape affect battery life expectancy?

***
- What we are looking at
![Standard Cell, http://en.wikipedia.org/wiki/File:Average_prokaryote_cell-_en.svg](ext-figures/Average_prokaryote_cell.svg) 
- What we get from the machine 
```{r, echo=FALSE,fig.cap="Single Cell",fig.height=3}
dkimg<-jpeg::readJPEG("ext-figures/Average_prokaryote_cell.jpg")
gray.img<-sqrt(1-(dkimg[,,1]+dkimg[,,2]+dkimg[,,3])/3)
cellImage<-im.to.df(gray.img)
ggplot(cellImage,aes(x=y,y=-x,fill=val))+
  geom_tile()+guides(fill=F)+theme_bw(20)
```


To test a hypothesis
========================================================
- We perform an experiment bone to see how big the cells are inside the tissue
$$\downarrow$$ ![Bone Measurement](ext-figures/tomoimage.png) 

### 2560 x 2560 x 2160 x 32 bit = 56GB / sample
- Filtering and Preprocessing!  
$$\downarrow$$
- 20h of computer time later ...
- 56GB of less noisy data
- Way too much data, we need to reduce

What did we want in the first place
========================================================
### _Single number_:
* volume fraction,
* cell count,
* average cell stretch,
* cell volume variability

Why do we perform segmentation?
========================================================
- In model-based analysis every step we peform, simple or complicated is related to an underlying model of the system we are dealing with
- Occam's Razor is very important here : The simplest solution is usually the right one
 - Bayesian, neural networks optimized using genetic algorithms with Fuzzy logic has a much larger parameter space to explore, establish sensitivity in, and must perform much better and be tested much more thoroughly than thresholding to be justified

Review: Filtering and Image Enhancement
========================================================
type: sub-section
incremental: true
- This was a noise process which was added to otherwise clean imaging data
- $$ I_{measured}(x,y) = I_{real}(x,y) + \text{Noise}(x,y) $$
- What would the perfect filter be
 - $$ \textit{Filter} \ast I_{real}(x,y) = I_{real}(x,y) $$
 - $$ \textit{Filter} \ast \text{Noise}(x,y) = 0 $$ 
 - $$ \textit{Filter} \ast I_{measured}(x,y)) = \text{Filter} \ast I_{real}(x,y) + \textit{Filter}\ast \text{Noise}(x,y) \rightarrow \bf I_{real}(x,y) $$
 

What did people used to do?
========================================================
- What comes out of our detector / enhancement process 
```{r, echo=FALSE,fig.cap="Single Cell",fig.height=5}
ggplot(cellImage,aes(x=y,y=400-x,fill=val))+
  geom_tile()+guides(fill=F)+theme_bw(20)+labs(x="x",y="y")
```
***
- Identify objects by eye
 - Count, describe qualitatively: "many little cilia on surface", "long curly flaggelum", "elongated nuclear structure"
- Morphometrics
 - Trace the outline of the object (or sub-structures)
 - Can calculate the area by using equal-weight-paper and employing the "[cut-and-weigh](http://ion.chem.usu.edu/~sbialkow/Classes/361/GC/GC.html)" method

 

Quantitative Analysis
========================================================
- For segmentation this model is: 
 - there are 2 (or more) distinct components that make up the image
 - these components are distinguishable by their values (or vectors, colors, tensors, ...)
 - For absorption/attenuation microscopy, [Beer-Lambert Law](http://en.wikipedia.org/wiki/Attenuation_coefficient)
 $$ I_{detector} = I_{source}\exp(-\alpha d) $$
 - Different components have either a different $\alpha$ or a different _d_
 
```{r, echo=FALSE,fig.cap="",fig.height=4}
nx<-4
ny<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*2*pi,y=c(-ny:ny)/ny*2*pi)
phase.im<-runif(nrow(grad.im))
grad.im<-cbind(grad.im,
               col=1*(phase.im>0.66)+
                 2*(phase.im<0.33)+
                 0.4*runif(nrow(grad.im),min=-1,max=1))
bn.wid<-diff(range(grad.im$col))/10
ggplot(grad.im,aes(x=col))+
  geom_density(aes(fill=cut_interval(col,3)))+
  geom_segment(data=data.frame(
    x=c(0.5,1.5),y=c(0),
    xend=c(0.5,1.5),yend=c(6)
    ),aes(x=x,y=y,xend=xend,yend=yend),fill="red",size=3,alpha=0.5)+
  labs(x="Gray Value",y="Frequency",title="Probability Density Function",fill="Groups")+
  theme_bw(20)
```

 
Where does segmentation get us?
========================================================
incremental: true

- We convert a decimal value (or something even more complicated like 3 values for RGB images, a spectrum for hyperspectral imaging, or a vector / tensor in a mechanical stress field)
- to a single, discrete value (usually true or false, but for images with phases it would be each phase, e.g. bone, air, cellular tissue)

- __2560 x 2560 x 2160 x 32 bit = 56GB / sample__
- $$\downarrow$$
- 2560 x 2560 x 2160 x **1 bit** = 1.75GB / sample

Applying a threshold to an image
========================================================
type: sub-section
Start out with a simple image of a cross with added noise
$$ I(x,y) = f(x,y) $$
```{r, echo=FALSE,fig.cap=""}
nx<-5
ny<-5
cross.im<-expand.grid(x=c(-nx:nx)/nx*2*pi,y=c(-ny:ny)/ny*2*pi)
cross.im<-cbind(cross.im,
               col=1.5*with(cross.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(cross.im)))
bn.wid<-diff(range(cross.im$col))/10
ggplot(cross.im,aes(x=x,y=y,fill=col))+
  geom_tile()+
  scale_fill_gradient(low="black",high="white")+
  labs(fill="Intensity")+
  theme_bw(20)
```
***
The intensity can be described with a probability density function 
$$ P_f(x,y) $$
```{r, echo=FALSE,fig.cap="Probability density function"}
ggplot(cross.im,aes(x=col))+geom_histogram(binwidth=bn.wid)+
  labs(x="Intensity",title="Probability Density Function")+
  theme_bw(20)
```

Applying a threshold to an image
========================================================
By examining the image and probability distribution function, we can _deduce_ that the underyling model is a whitish phase that makes up the cross and the darkish background
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
thresh.val<-0.75
cross.im$val<-(cross.im$col>=thresh.val)
ggplot(cross.im,aes(x=x,y=y))+
  geom_tile(aes(fill=col))+
  geom_tile(data=subset(cross.im,val),fill="red",color="black",alpha=0.3)+
  geom_tile(data=subset(cross.im,!val),fill="blue",color="black",alpha=0.3)+
  scale_fill_gradient(low="black",high="white")+
  labs(fill="Intensity")+
  theme_bw(20)
```
***
Applying the threshold is a deceptively simple operation
$$ I(x,y) = 
\begin{cases}
1, & f(x,y)\geq0.5 \\
0, & f(x,y)<0.5
\end{cases}$$
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
ggplot(cbind(cross.im,in.thresh=cross.im$col>=thresh.val),aes(x=col))+
  geom_histogram(binwidth=bn.wid,aes(fill=in.thresh))+
  labs(x="Intensity",color="In Threshold")+scale_fill_manual(values=c("blue","red"))+
  theme_bw(20)
```
Various Thresholds
========================================================
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
thresh.vals<-c(1:9)/9
grad.im.th<-ldply(thresh.vals,function(thresh.val) 
  cbind(grad.im,thresh=thresh.val,in.thresh=(grad.im$col>=thresh.val)))
ggplot(grad.im.th,aes(x=x,y=y))+
  geom_tile(aes(fill=in.thresh),color="black",alpha=0.75)+
  labs(fill="Above Threshold")+facet_wrap(~thresh)+
  theme_bw(20)
```
***
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
ggplot(grad.im.th,aes(x=col))+
  geom_histogram(binwidth=bn.wid,aes(fill=in.thresh))+
  labs(x="Intensity",fill="Above Threshold")+facet_wrap(~thresh)+
  theme_bw(20)
```
Segmenting Cells
========================================================
```{r, echo=FALSE,fig.cap="Cell Colony"}

cellImage<-im.to.df(jpeg::readJPEG("Cell_Colony.jpg"))
ggplot(cellImage,aes(x=x,y=y,fill=val))+
  geom_tile()+guides(fill=F)+theme_bw(20)
```
```{r, echo=FALSE}
ggplot(cellImage,aes(x=val))+geom_histogram()+theme_bw(20)
```
***
- We can peform the same sort of analysis with this image of cells
- This time we can derive the model from the basic physics of the system
 - The field is illuminated by white light of nearly uniform brightness
 - Cells absorb light causing darker regions to appear in the image
 - _Lighter_ regions have no cells
 - __Darker__ regions have cells

Different Threshold Values
========================================================
```{r, echo=FALSE,fig.cap="Cell Colony"}
th.vals<-seq(0.4,0.85,length.out=3)
thlabel<-function(x,...) switch(x,"Too low","Good","Too high")
im.vals<-ldply(1:length(th.vals),function(th.val)
  cbind(cellImage,
        in.thresh=ifelse(cellImage$val<th.vals[th.val],"Cell","Background"),
        th.val=th.vals[th.val],
        th.label=thlabel(th.val)))
ggplot(im.vals,aes(x=x,y=y,fill=in.thresh))+
  geom_raster()+guides(fill=F)+theme_bw(20)+facet_grid(th.label~.)
```
***
```{r, echo=FALSE}
ggplot(im.vals,aes(x=val))+geom_histogram(aes(fill=in.thresh))+
  scale_y_sqrt()+
  theme_bw(20)+facet_grid(th.label~.)+labs(x="Intensity",y="Count",fill="Phase")
```

Other Image Types
========================================================
While scalar images are easiest, it is possible for any type of image
$$ I(x,y) = \vec{f}(x,y) $$
```{r, echo=FALSE,fig.cap=""}
nx<-7
ny<-7
n.pi<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*n.pi*pi,y=c(-ny:ny)/ny*n.pi*pi)

grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)),
               x.vec=with(grad.im,y),
               y.vec=with(grad.im,x))
# normalize vector
grad.im[,c("x.vec","y.vec")]<-with(grad.im,cbind(x.vec/(sqrt(x.vec^2+y.vec^2)),
                                         y.vec/(sqrt(x.vec^2+y.vec^2))))
bn.wid<-c(diff(range(grad.im$x.vec))/10,diff(range(grad.im$y.vec))/10)
ggplot(grad.im,aes(x=x,y=y,fill=col))+
  #geom_tile(alpha=0.5)+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.15,"cm")),size=3)+
  scale_fill_gradient(low="black",high="white")+
  theme_bw(20)
```
***
The intensity can be described with two seperate or a single joint probability density function
$$ P_{\vec{f}\cdot \vec{i}}(x,y), P_{\vec{f}\cdot \vec{j}}(x,y) $$
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
ggplot(grad.im,aes(x=x.vec,y=y.vec))+
  stat_bin2d(binwidth=c(0.25,.25),drop=F)+
  labs(x="Pfx",y="Pfy",fill="Frequency")+
  xlim(-1,1)+ylim(-1,1)+
  theme_bw(20)
```


Applying a threshold
========================================================
A threshold is now more difficult to apply since there are now two distinct variables to deal with. The standard approach can be applied to both
$$ I(x,y) = 
\begin{cases}
1, & \vec{f}_x(x,y) \geq0.25 \text{ and}\\
& \vec{f}_y(x,y) \geq0.25 \\
0, & \text{otherwise}
\end{cases}$$
```{r, echo=FALSE,fig.cap=""}
g.with.thresh<-cbind(grad.im,in.thresh=with(grad.im,x.vec>0.25 & y.vec>0.25))
ggplot(g.with.thresh,
       aes(x=x,y=y,fill=in.thresh,color=in.thresh))+
  geom_tile(alpha=0.5,aes(fill=in.thresh))+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.2,"cm")),size=3)+
  labs(color="In Threshold")+guides(fill=FALSE)+
  theme_bw(20)
```
***
This can also be shown on the joint probability distribution as 
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
bn.wid<-c(0.25,.25)
keep.bins<-expand.grid(x.vec=seq(-1,1,bn.wid[1]/10),y.vec=seq(-1,1,bn.wid[2]/10))
keep.bins<-cbind(keep.bins,in.thresh=with(keep.bins,x.vec>0.25 & y.vec>0.25))
ggplot(g.with.thresh,aes(x=x.vec,y=y.vec))+
  stat_bin2d(binwidth=bn.wid,drop=F)+
  geom_tile(data=subset(g.with.thresh,in.thresh),fill="red",alpha=0.4)+
  labs(x="Pfx",y="Pfy",fill="Threshold")+xlim(-1,1)+ylim(-1,1)+
  theme_bw(20)
```

Applying a threshold
========================================================
Given the presence of two variables; however, more advanced approaches can also be investigated. For example we can keep only components parallel to the x axis by using the dot product.
$$ I(x,y) = 
\begin{cases}
1, & |\vec{f}(x,y)\cdot \vec{i}| = 1 \\
0, & \text{otherwise}
\end{cases}$$
```{r ,fig.cap="",fig.width=7,fig.height=4}
i.vec<-c(1,0)
j.vec<-c(0,1)
g.cmp.thresh<-cbind(grad.im,in.thresh=with(grad.im,
                                            abs(x.vec*i.vec[1]+y.vec*i.vec[2])==1
                                            ))
ggplot(g.cmp.thresh,
       aes(x=x,y=y,fill=in.thresh,color=in.thresh))+
  geom_tile(alpha=0.5,aes(fill=in.thresh))+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.2,"cm")),size=3)+
  labs(color="In Threshold")+guides(fill=FALSE)+
  theme_bw(20)
```
Looking at Orientations
========================================================
We can tune the angular acceptance by using the fact $$\vec{x}\cdot\vec{y}=|\vec{x}| |\vec{y}| \cos(\theta_{x\rightarrow y}) $$
$$ I(x,y) = 
\begin{cases}
1, & \cos^{-1}(\vec{f}(x,y)\cdot \vec{i}) \leq \theta^{\circ} \\
0, & \text{otherwise}
\end{cases}$$
***
```{r, echo=FALSE,fig.cap="",results='hide'}
i.vec<-c(1,0)
j.vec<-c(0,1)
ang.accept<-function(c.ang) g.cmp.thresh<-cbind(grad.im,
                                                ang.val=c.ang,
                                                in.thresh=with(grad.im,
                                            acos(x.vec*i.vec[1]+y.vec*i.vec[2])<=c.ang/180*pi
                                            ))
ang.vals<-seq(5,180,length.out=9)
ggplot(ldply(ang.vals,ang.accept),
       aes(x=x,y=y,fill=in.thresh,color=in.thresh))+
  geom_tile(alpha=0.5,aes(fill=in.thresh))+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.2,"cm")),size=3)+
  facet_wrap(~ang.val)+
  labs(color="In Threshold")+guides(fill=FALSE)
  theme_bw(20)
```


Other Image Types
========================================================
Going beyond vector the possibilities for images are limitless. The following shows a tensor plot with the tensor represented as an ellipse. 
$$ I(x,y) = \hat{f}(x,y) $$
```{r, echo=FALSE,fig.cap="",fig.height=3}
source('~/Dropbox/TIPL/src/R/shapeAnalysisProcess.R')
nx<-3
ny<-3
n.pi<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*n.pi*pi,
                     y=c(-ny:ny)/ny*n.pi*pi)

grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)),
              a=with(grad.im,sqrt(2/(abs(x)+0.5))),
               b=with(grad.im,0.5*sqrt(abs(x)+1)),
              th=0.5*runif(nrow(grad.im)),
              aiso=1,count=1)


deform.ellipse.draw<-function(c.box) {
  create.ellipse.points(x.off=c.box$x[1],
                        y.off=c.box$y[1],
                        a=c.box$a[1],
                        b=c.box$b[1],
                        th.off=c.box$th[1],
                        col=c.box$col[1])                    
}

# normalize vector
tens.im<-ddply(grad.im,.(x,y),deform.ellipse.draw)

ggplot(tens.im,aes(x=x,y=y,group=as.factor(id),fill=col))+
  geom_polygon(color="black")+coord_fixed(ratio=1)+scale_fill_gradient(low="black",high="white")+guides(fill=F)+
  theme_bw(20)
```
Once the variable count is above 2, individual density functions and a series of cross plots are easier to interpret than some multidimensional density hypervolume.
***

```{r, echo=FALSE,fig.cap="Variable distributions",fig.height=4}
ggplot(grad.im)+
  geom_histogram(aes(x=a,fill="Width"),alpha=0.7)+
  geom_histogram(aes(x=b,fill="Height"),alpha=0.7)+
  geom_histogram(aes(x=th,fill="Orientation"),alpha=0.7)+
  geom_histogram(aes(x=col,fill="Color"),alpha=0.7)+
  guides(color=F)+labs(fill="Variable")+
  theme_bw(15)
```
```{r, echo=FALSE,fig.cap="With Threshold Overlay",fig.height=4}
plot(grad.im[,c("a","b","th","col")])
```

Multiple Phases: Segmenting Shale
========================================================
% Shale provided from Kanitpanyacharoen, W. (2012). Synchrotron X-ray Applications Toward an Understanding of Elastic Anisotropy.
- Here we have a shale sample measured with X-ray tomography with three different phases inside (clay, rock, and air).
- The model is that because the chemical composition and density of each phase is different they will absorb different amounts of x-rays and appear as different brightnesses in the image
```{r, echo=FALSE,fig.cap="Shale Sample"}
im.to.df<-function(in.img) {
    out.im<-expand.grid(x=1:nrow(in.img),y=1:ncol(in.img))
    out.im$val<-as.vector(in.img)
    out.im
}
shaleImage<-im.to.df(jpeg::readJPEG("ext-figures/ShaleSample.jpg"))
ggplot(shaleImage,aes(x=x,y=y,fill=val))+
  geom_tile()+
  labs(fill="Absorption (au)")+theme_bw(20)
```
***
Ideally we would derive 3 values for the thresholds based on a model for the composition of each phase and how much it absorbs, but that is not always possible or practical.
- While there are 3 phases clearly visible in the image, the histogram is less telling (even after being re-scaled).
```{r, echo=FALSE}
ggplot(shaleImage,aes(x=val))+geom_histogram()+
  scale_y_sqrt()+
  labs(x="Absorption Intensity",y="Counts")+theme_bw(20)
```

Multiple Segmentations
========================================================
For this exercise we choose arbitrarily 3 ranges for the different phases and perform visual inspection
```{r, echo=FALSE}
void.max<-0.2
clay.max<-0.5
thresh.fun<-function(x.val) {
  if(x.val<void.max) "Void"
  else if (x.val>void.max & x.val<clay.max) "Clay"
  else "Rock"
}
shale.vals<-cbind(shaleImage,th.label=sapply(shaleImage$val,thresh.fun))
ggplot(shale.vals,aes(x=val))+geom_histogram(aes(fill=th.label))+
  scale_y_sqrt()+
  theme_bw(20)+labs(x="Intensity",y="Count")
```
***
The relation can explicitly be written out as
$$ I(x) = 
\begin{cases}
\text{Void}, & 0 \leq x \leq 0.2  \\
\text{Clay}, & 0.2 < x \leq 0.5 \\
\text{Rock}, & 0.5 < x
\end{cases}$$
```{r, echo=FALSE,fig.cap="Segmented Images"}
ggplot(shale.vals,aes(x=x,y=y,fill=th.label,alpha=1-val))+coord_fixed(ratio=1)+
  geom_raster()+guides(fill=F,alpha=F)+theme_bw(20)+facet_wrap(~th.label)
```

Implementation
========================================================
The implementations of basic thresholds and segmentations is very easy since it is a unary operation of a single image
$$ f(I(\vec{x})) $$
In mathematical terms this is called a map and since it does not require information from neighboring voxels or images it can be calculated for each point independently (_parallel_). Filters on the other hand almost always depend on neighboring voxels and thus the calculations are not as easy to seperate.

Morphology
========================================================
Returning to the original image of a cross
```{r, echo=FALSE,fig.cap="Cross With Threshold Overlay"}
nx<-8
ny<-8
cross.im<-expand.grid(x=c(-nx:nx)/nx*2*pi,y=c(-ny:ny)/ny*2*pi)
cross.im<-cbind(cross.im,
               col=with(cross.im,1.5*((abs(x)<2) | (abs(y)<2))+
                 0.5*runif(nrow(cross.im))))
thresh.val<-0.75
cross.im$val<-(cross.im$col>=thresh.val)
ggplot(cross.im,aes(x=x,y=y))+
  geom_tile(aes(fill=col))+
  geom_tile(data=subset(cross.im,val),fill="red",color="black",alpha=0.3)+
  geom_tile(data=subset(cross.im,!val),fill="blue",color="black",alpha=0.3)+
  scale_fill_gradient(low="black",high="white")+
  labs(fill="Intensity")+
  theme_bw(20)
```
We can now utilize information from neighborhood voxels to improve the results. These steps are called morphological operations.
***
Like filtering the assumption behind morphological operations are
- nearby voxels in __real__ images are related / strongly correlated with one another 
- noise and imaging artifacts are less spatially correlated. 

Therefore these imaging problems can be alleviated by adjusting the balance between local and neighborhood values.

Morphology: Neighbors in 2D
========================================================
For standard morphological operations there are two definitions of neighborhood. The 4 and 8 adjacent neighbors shown below. Given the blue pixel in the center the red are the 4-adjacent and the red and green make up the 8 adjacent. 
```{r, echo=FALSE,fig.cap=""}
morph.2d<-expand.grid(x=c(-1,0,1),y=c(-1,0,1))
morph.2d$r<-with(morph.2d,sqrt(x^2+y^2))

ggplot(morph.2d,aes(x=x,y=y))+
  geom_tile(color="black",
            aes(fill=ifelse(r==0,"Pixel of Interest",
                                   ifelse(r==1,"4-Adjacent","8-Adjacent")))
            )+
  geom_text(aes(label=3*(y+1)+x+1))+
  labs(fill="Pixel Type")+
  theme_bw(20)
```

Formal Neighborhood Definitions
========================================================
Formally these have two effectively equivalent, but different definitions. 
- Pixels which share a face (red line) with the pixel
- Pixels which share a vertex (yellow dot) with the pixel

```{r, echo=FALSE,fig.cap="",fig.height=3}

cent.pix<-data.frame(x=c(-1, 1,1,-1,-1)/2,
                     y=c(-1,-1,1, 1,-1)/2)
ggplot(morph.2d,aes(x=x,y=y))+
  geom_tile(color="black",size=1,alpha=0.7,
            aes(fill=ifelse(r==0,"Pixel of Interest",
                                   ifelse(r==1,"4-Adjacent","8-Adjacent")))
            )+
  geom_path(data=cent.pix,color="red",size=3)+
  geom_point(data=cent.pix,color="yellow",size=5)+
  geom_text(aes(label=3*(y+1)+x+1))+
  labs(fill="Pixel Type")+
  theme_bw(20)
```
***
- Pixels which are distance 1 from the pixel
- Pixels which are distance $$\sqrt{2}$$ from the pixel
```{r, echo=FALSE,fig.cap="",fig.height=3}
morph.2d<-expand.grid(x=c(-1,0,1),y=c(-1,0,1))
morph.2d$r<-with(morph.2d,sqrt(x^2+y^2))
ggplot(morph.2d,aes(x=x,y=y))+
  geom_tile(color="black",
            aes(fill=ifelse(r==0,"Pixel of Interest",
                                   ifelse(r==1,"4-Adjacent","8-Adjacent")))
            )+
  geom_text(aes(label=round(r*100)/100))+
  labs(fill="Pixel Type")+
  theme_bw(20)
```

Formal Neighborhood Definitions in 3D
========================================================
In 3D there is now an additional group to consider because of the extra-dimension
- Voxels which share a face (red line) with the voxel (6-adjacent)
- Voxels which share an edge (yellow dot) with the voxel (18-adjacent)
- Voxels which share a vertex (purple dot) with the voxel (26-adjacent)

```{r, echo=FALSE,fig.cap="",fig.height=3}
morph.3d<-expand.grid(x=c(-1,0,1),y=c(-1,0,1),z=c(-1,0,1))
morph.3d$r<-with(morph.3d,sqrt(x^2+y^2+z^2))

cent.pix.3d<-data.frame(x=c(-1, 1,1,-1,-1,-1, 1,1,-1,-1)/2,
                     y=c(-1,-1,1, 1,-1,-1,-1,1, 1,-1)/2,
                     z=c(-1,-1,-1,-1,-1,1, 1,1, 1, 1))
face.pix.3d<-data.frame(x=c(-1, 1, 1,-1,-1)/2,
                        y=c(-1,-1, 1, 1,-1)/2,
                        z=c( 0, 0, 0, 0, 0))
pixel.label<-function(r) ifelse(r==0,"Pixel of Interest",
                                   ifelse(r==1," 6-Adjacent",
                                          ifelse(r==sqrt(2),"18-Adjacent","26-Adjacent")))
ggplot(morph.3d,aes(x=x,y=y))+
  geom_tile(color="black",size=1,alpha=0.7,
            aes(fill=pixel.label(r))
            )+
  geom_path(data=cent.pix.3d,color="yellow",size=3)+
  geom_point(data=cent.pix.3d,color="purple",size=5)+
  geom_path(data=face.pix.3d,color="red",size=3)+
  geom_point(data=face.pix.3d,color="yellow",size=5)+
  geom_text(aes(label=9*(z+1)+3*(y+1)+x+1))+
  facet_grid(~z)+
  labs(fill="Pixel Type")+
  theme_bw(20)
```
***
- Voxels which are distance 1 from the voxel
- Voxels which are distance $$\sqrt{2}$$ from the voxel
- Voxels which are distance $$\sqrt{3}$$ from the voxel
```{r, echo=FALSE,fig.cap="",fig.height=3}
ggplot(morph.3d,aes(x=x,y=y))+
  geom_tile(color="black",size=1,
            aes(fill=pixel.label(r))
            )+
  geom_text(aes(label=round(r*100)/100))+
  facet_grid(~z)+
  labs(fill="Pixel Type")+
  theme_bw(14)
```

What do we do with it?
========================================================
A neighborhood or representative volume is the basis for a large number of image processing operations:
- filtering
- morphological operations
- component labeling
- distance maps
- image correlation based tracking methods

Erosion and Dilation
========================================================
type:alert

Applied Erosion and Dilation
========================================================
Taking an image of the cross at a too-high threshold, we show how dilation can be used to recover some of the missing pixels
```{r, echo=FALSE,fig.cap="Dilation Example",fig.height=3}
cross.im$thresh<-cross.im$col>1.75

cross.mat<-df.to.im(cross.im,"thresh",inv=T)
cross.df<-im.to.df(cross.mat)
ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  labs(fill="Type")+
  theme_bw(20)
```
```{r, echo=FALSE,fig.cap="Dilation Example",fig.height=3}
cross.dil.mat<-imgStdBinaryDilation(cross.mat)
cross.dil.df<-im.to.df(cross.dil.mat)

ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  geom_tile(data=subset(cross.dil.df,val==0),aes(fill="post dilation"),color="black",alpha=0.3)+
  labs(fill="Type")+
  theme_bw(20)
```
***
Taking an image of the cross at a too-low threshold, we show how erosion can be used to remove some of the extra pixels
```{r, echo=FALSE,fig.cap="Erosion Example",fig.height=3}
cross.im$thresh<-cross.im$col>0.4
cross.mat<-df.to.im(cross.im,"thresh",inv=T)
cross.df<-im.to.df(cross.mat)
ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  labs(fill="Type")+
  theme_bw(20)
```
```{r, echo=FALSE,fig.cap="Erosion Example"}

cross.ero.mat<-imgStdBinaryErosion(cross.mat)
cross.ero.df<-im.to.df(cross.ero.mat)
ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  geom_tile(data=subset(cross.ero.df,val==0),aes(fill="post erosion"),color="black",alpha=0.3)+
  labs(fill="Type")+
  theme_bw(20)
```
We can now utilize information from neighborhood voxels to improve the results. These steps are called morphological operations.


Applied Opening and Closing
========================================================
Taking an image of the cross at a too-high threshold, we show how closing can be used to recover some of the missing pixels
```{r, echo=FALSE,fig.cap="Dilation Example",fig.height=3}
cross.im$thresh<-cross.im$col>1.75

cross.mat<-df.to.im(cross.im,"thresh",inv=T)
cross.df<-im.to.df(cross.mat)
ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  labs(fill="Type")+
  theme_bw(20)
```
```{r, echo=FALSE,fig.cap="Dilation Example",fig.height=3}
cross.dil.mat<-imgStdBinaryClosing(cross.mat)
cross.dil.df<-im.to.df(cross.dil.mat)

ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  geom_tile(data=subset(cross.dil.df,val==0),aes(fill="post dilation"),color="black",alpha=0.3)+
  labs(fill="Type")+
  theme_bw(20)
```
***
Taking an image of the cross at a too-low threshold, we show how opening can be used to remove some of the extra pixels
```{r, echo=FALSE,fig.cap="Erosion Example",fig.height=3}
cross.im$thresh<-cross.im$col>0.4
cross.mat<-df.to.im(cross.im,"thresh",inv=T)
cross.df<-im.to.df(cross.mat)
ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  labs(fill="Type")+
  theme_bw(20)
```
```{r, echo=FALSE,fig.cap="Erosion Example"}

cross.ero.mat<-imgStdBinaryOpening(cross.mat)
cross.ero.df<-im.to.df(cross.ero.mat)
ggplot(cross.df,aes(x=x,y=y))+
  geom_tile(data=subset(cross.df,val==0),aes(fill="original"),color="black",alpha=0.7)+
  geom_tile(data=subset(cross.ero.df,val==0),aes(fill="post erosion"),color="black",alpha=0.3)+
  labs(fill="Type")+
  theme_bw(20)
```
We can now utilize information from neighborhood voxels to improve the results. These steps are called morphological operations.

Segmenting Fossils!
========================================================
<video controls>
  <source src="ext-figures/PaleontologyMovie.m4v" type="video/mp4">
Your browser does not support the video tag.
</video>
