```{r global_setup, echo=FALSE, warning=FALSE, cache=FALSE}
library(knitr)
opts_chunk$set(dev="CairoPNG",dpi=150,cache=T,results='hide',warning=F,fig.align='center',echo=F)
library(ggplot2)
library(plyr)
library(grid) # contains the arrow function
```

Quantitative Big Imaging  
========================================================
author: Kevin Mader
date: 6 March 2014
width: 1440
height: 900
transition: rotate

## Basic Segmentation and Discrete Binary Structures


Course Outline
========================================================
- 20th February - Introductory Lecture
- 27th February - Filtering and Image Enhancement (A. Kaestner)
- 6th March - **Basic Segmentation, Discrete Binary Structures**
- 13th March - Advanced Segmentation
- 20th March - Analyzing Single Objects
- 27th March -  Analyzing Complex Objects
- 3rd April -  Spatial Distribution
- 10th April -  Statistics and Reproducibility
- 17th April - Dynamic Experiments
- 8th May - Big Data
- 15th May - Guest Lecture - Applications in Material Science
- 22th May - Project Presentations

Literature / Useful References
========================================================
- Jean Claude, Morphometry with R
 - Online through ETHZ at http://link.springer.com/book/10.1007%2F978-0-387-77789-4
 - Buy it at: http://www.amazon.com/Morphometrics-R-Use-Julien-Claude/dp/038777789X
- John C. Russ, “The Image Processing Handbook”,(Boca Raton, CRC Press)
 - Available online within domain ethz.ch (or proxy.ethz.ch / public VPN) http://dx.doi.org/10.1201/9780203881095

Motivation:  Why do we do imaging experiments?
========================================================
incremental: true

- To get an idea of what is going on
- To test a hypothesis
 - Does temperature affect bubble size?
 - Is this gene important for cell shape and thus mechanosensation in bone?
 - Does higher canal volume make bones weaker?
 - Does the granule shape affect battery life expectancy?


To test a hypothesis
========================================================
- We perform an experiment bone to see how big the cells are inside the tissue
$$\downarrow$$ ![Bone Measurement](ext-figures/tomoimage.png) 

### 2560 x 2560 x 2160 x 32 bit = 56GB / sample
- Filtering and Preprocessing!  
$$\downarrow$$
- 20h of computer time later ...
- 56GB of less noisy data
- Way too much data, we need to reduce

What did we want in the first place
========================================================
type: sub-section
### _Single number_:
* volume fraction,
* cell count,
* average cell stretch,
* cell volume variability

Where does segmentation get us?
========================================================
incremental: true

- We convert a decimal value (or something even more complicated like 3 values for RGB images, a spectrum for hyperspectral imaging, or a vector / tensor in a mechanical stress field)
- Each point reduces to a single value  

- __2560 x 2560 x 2160 x 32 bit = 56GB / sample__
- $$\downarrow$$
- 2560 x 2560 x 2160 x **1 bit** = 1.75GB / sample

Applying a threshold to an image
========================================================
type: sub-section
Start out with a simple image of a cross with added noise
$$ I(x,y) = f(x,y) $$
```{r, echo=FALSE,fig.cap=""}
nx<-5
ny<-5
grad.im<-expand.grid(x=c(-nx:nx)/nx*2*pi,y=c(-ny:ny)/ny*2*pi)
grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)))
bn.wid<-diff(range(grad.im$col))/10
ggplot(grad.im,aes(x=x,y=y,fill=col))+
  geom_tile()+
  scale_fill_gradient(low="black",high="white")+
  labs(fill="Intensity")+
  theme_bw(20)
```
***
The intensity can be described with a probability density function 
$$ P_f(x,y) $$
```{r, echo=FALSE,fig.cap="Probability density function"}
ggplot(grad.im,aes(x=col))+geom_histogram(binwidth=bn.wid)+
  labs(x="Intensity",title="Probability Density Function")+
  theme_bw(20)
```

Applying a threshold to an image
========================================================
A threshold for scalar images is a very simple operation
$$ I(x,y) = 
\begin{cases}
1, & f(x,y)\geq0.5 \\
0, & f(x,y)<0.5
\end{cases}$$
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
thresh.val<-0.75
ggplot(grad.im,aes(x=x,y=y))+
  geom_tile(aes(fill=col))+
  geom_tile(data=subset(grad.im,col>=thresh.val),fill="red",color="black",alpha=0.3)+
  geom_tile(data=subset(grad.im,col<thresh.val),fill="blue",color="black",alpha=0.3)+
  scale_fill_gradient(low="black",high="white")+
  labs(fill="Intensity")+
  theme_bw(20)
```
***
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
ggplot(cbind(grad.im,in.thresh=grad.im$col>=thresh.val),aes(x=col))+
  geom_histogram(binwidth=bn.wid,aes(fill=in.thresh))+
  labs(x="Intensity",color="In Threshold")+scale_fill_manual(values=c("blue","red"))+
  theme_bw(20)
```
Various Thresholds
========================================================
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
thresh.vals<-c(1:9)/9
grad.im.th<-ldply(thresh.vals,function(thresh.val) 
  cbind(grad.im,thresh=thresh.val,in.thresh=(grad.im$col>=thresh.val)))
ggplot(grad.im.th,aes(x=x,y=y))+
  geom_tile(aes(fill=in.thresh),color="black",alpha=0.75)+
  labs(fill="Above Threshold")+facet_wrap(~thresh)+
  theme_bw(20)
```
***
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
ggplot(grad.im.th,aes(x=col))+
  geom_histogram(binwidth=bn.wid,aes(fill=in.thresh))+
  labs(x="Intensity",fill="Above Threshold")+facet_wrap(~thresh)+
  theme_bw(20)
```
Segmenting Cells
========================================================
```{r, echo=FALSE,fig.cap="Cell Colony"}
im.to.df<-function(in.img) {
    out.im<-expand.grid(x=1:nrow(in.img),y=1:ncol(in.img))
    out.im$val<-as.vector(in.img)
    out.im
}
cellImage<-im.to.df(jpeg::readJPEG("Cell_Colony.jpg"))
ggplot(cellImage,aes(x=x,y=y,fill=val))+
  geom_tile()+guides(fill=F)+theme_bw(20)
```
***
```{r, echo=FALSE}
ggplot(cellImage,aes(x=val))+geom_histogram()+theme_bw(20)
```
Different Threshold Values
========================================================
```{r, echo=FALSE,fig.cap="Cell Colony"}
th.vals<-seq(0.4,0.85,length.out=3)
thlabel<-function(x,...) switch(x,"Too low","Good","Too high")
im.vals<-ldply(1:length(th.vals),function(th.val)
  cbind(cellImage,
        in.thresh=cellImage$val<th.vals[th.val],
        th.val=th.vals[th.val],
        th.label=thlabel(th.val)))
ggplot(im.vals,aes(x=x,y=y,fill=in.thresh))+
  geom_raster()+guides(fill=F)+theme_bw(20)+facet_grid(th.label~.)
```
***
```{r, echo=FALSE}
ggplot(im.vals,aes(x=val))+geom_histogram(aes(fill=in.thresh))+
  scale_y_sqrt()+
  theme_bw(20)+facet_grid(th.label~.)+labs(x="Intensity",y="Count")
```

Other Image Types
========================================================
While scalar images are easiest, it is possible for any type of image
$$ I(x,y) = \vec{f}(x,y) $$
```{r, echo=FALSE,fig.cap=""}
nx<-7
ny<-7
n.pi<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*n.pi*pi,y=c(-ny:ny)/ny*n.pi*pi)

grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)),
               x.vec=with(grad.im,y),
               y.vec=with(grad.im,x))
# normalize vector
grad.im[,c("x.vec","y.vec")]<-with(grad.im,cbind(x.vec/(sqrt(x.vec^2+y.vec^2)),
                                         y.vec/(sqrt(x.vec^2+y.vec^2))))
bn.wid<-c(diff(range(grad.im$x.vec))/10,diff(range(grad.im$y.vec))/10)
ggplot(grad.im,aes(x=x,y=y,fill=col))+
  #geom_tile(alpha=0.5)+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.15,"cm")),size=3)+
  scale_fill_gradient(low="black",high="white")+
  theme_bw(20)
```
***
The intensity can be described with two seperate or a single joint probability density function
$$ P_{\vec{f}\cdot \vec{i}}(x,y), P_{\vec{f}\cdot \vec{j}}(x,y) $$
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
ggplot(grad.im,aes(x=x.vec,y=y.vec))+
  stat_bin2d(binwidth=c(0.25,.25),drop=F)+
  labs(x="Pfx",y="Pfy",fill="Frequency")+
  xlim(-1,1)+ylim(-1,1)+
  theme_bw(20)
```


Applying a threshold
========================================================
A threshold is now more difficult to apply since there are now two distinct variables to deal with. The standard approach can be applied to both
$$ I(x,y) = 
\begin{cases}
1, & \vec{f}_x(x,y) \geq0.25 \text{ and}\\
& \vec{f}_y(x,y) \geq0.25 \\
0, & \text{otherwise}
\end{cases}$$
```{r, echo=FALSE,fig.cap=""}
g.with.thresh<-cbind(grad.im,in.thresh=with(grad.im,x.vec>0.25 & y.vec>0.25))
ggplot(g.with.thresh,
       aes(x=x,y=y,fill=in.thresh,color=in.thresh))+
  geom_tile(alpha=0.5,aes(fill=in.thresh))+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.2,"cm")),size=3)+
  labs(color="In Threshold")+guides(fill=FALSE)+
  theme_bw(20)
```
***
This can also be shown on the joint probability distribution as 
```{r, echo=FALSE,fig.cap="With Threshold Overlay"}
bn.wid<-c(0.25,.25)
keep.bins<-expand.grid(x.vec=seq(-1,1,bn.wid[1]/10),y.vec=seq(-1,1,bn.wid[2]/10))
keep.bins<-cbind(keep.bins,in.thresh=with(keep.bins,x.vec>0.25 & y.vec>0.25))
ggplot(g.with.thresh,aes(x=x.vec,y=y.vec))+
  stat_bin2d(binwidth=bn.wid,drop=F)+
  geom_tile(data=subset(g.with.thresh,in.thresh),fill="red",alpha=0.4)+
  labs(x="Pfx",y="Pfy",fill="Threshold")+xlim(-1,1)+ylim(-1,1)+
  theme_bw(20)
```

Applying a threshold
========================================================
Given the presence of two variables; however, more advanced approaches can also be investigated. For example we can keep only components parallel to the x axis by using the dot product.
$$ I(x,y) = 
\begin{cases}
1, & |\vec{f}(x,y)\cdot \vec{i}| = 1 \\
0, & \text{otherwise}
\end{cases}$$
```{r ,fig.cap="",fig.width=7,fig.height=4}
i.vec<-c(1,0)
j.vec<-c(0,1)
g.cmp.thresh<-cbind(grad.im,in.thresh=with(grad.im,
                                            abs(x.vec*i.vec[1]+y.vec*i.vec[2])==1
                                            ))
ggplot(g.cmp.thresh,
       aes(x=x,y=y,fill=in.thresh,color=in.thresh))+
  geom_tile(alpha=0.5,aes(fill=in.thresh))+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.2,"cm")),size=3)+
  labs(color="In Threshold")+guides(fill=FALSE)+
  theme_bw(20)
```
Looking at Orientations
========================================================
We can tune the angular acceptance by using the fact $$\vec{x}\cdot\vec{y}=|\vec{x}| |\vec{y}| \cos(\theta_{x\rightarrow y}) $$
$$ I(x,y) = 
\begin{cases}
1, & \cos^{-1}(\vec{f}(x,y)\cdot \vec{i}) \leq \theta^{\circ} \\
0, & \text{otherwise}
\end{cases}$$
***
```{r, echo=FALSE,fig.cap="",results='hide'}
i.vec<-c(1,0)
j.vec<-c(0,1)
ang.accept<-function(c.ang) g.cmp.thresh<-cbind(grad.im,
                                                ang.val=c.ang,
                                                in.thresh=with(grad.im,
                                            acos(x.vec*i.vec[1]+y.vec*i.vec[2])<=c.ang/180*pi
                                            ))
ang.vals<-seq(5,180,length.out=9)
ggplot(ldply(ang.vals,ang.accept),
       aes(x=x,y=y,fill=in.thresh,color=in.thresh))+
  geom_tile(alpha=0.5,aes(fill=in.thresh))+
  geom_segment(aes(xend=x+x.vec,yend=y+y.vec),arrow=arrow(length = unit(0.2,"cm")),size=3)+
  facet_wrap(~ang.val)+
  labs(color="In Threshold")+guides(fill=FALSE)
  theme_bw(20)
```


Other Image Types
========================================================
Going beyond vector the possibilities for images are limitless. The following shows a tensor plot with the tensor represented as an ellipse. 
$$ I(x,y) = \hat{f}(x,y) $$
```{r, echo=FALSE,fig.cap=""}
source('~/Dropbox/TIPL/src/R/shapeAnalysisProcess.R')
nx<-3
ny<-3
n.pi<-4
grad.im<-expand.grid(x=c(-nx:nx)/nx*n.pi*pi,
                     y=c(-ny:ny)/ny*n.pi*pi)

grad.im<-cbind(grad.im,
               col=1.5*with(grad.im,abs(cos(x*y))/(abs(x*y)+(3*pi/nx)))+
                 0.5*runif(nrow(grad.im)),
              a=with(grad.im,sqrt(1/(abs(x)+0.5))),
               b=with(grad.im,sqrt(x)),
              th=0.5*runif(nrow(grad.im)),
              aiso=1,count=1)


deform.ellipse.draw<-function(c.box) {
  create.ellipse.points(x.off=c.box$x[1],
                        y.off=c.box$y[1],
                        a=c.box$a[1],
                        b=c.box$b[1],
                        th.off=c.box$th[1],
                        col=c.box$col[1])                    
}

# normalize vector
tens.im<-ddply(grad.im,.(x,y),deform.ellipse.draw)

ggplot(tens.im,aes(x=x,y=y,group=as.factor(id),fill=col))+
  geom_polygon(color="black")+coord_fixed(ratio=1)+scale_fill_gradient(low="black",high="white")+guides(fill=F)+
  theme_bw(20)
```
***
```{r, echo=FALSE,fig.cap="Variable distributions",fig.height=3}
ggplot(grad.im,aes(color="black"))+
  geom_histogram(aes(x=a,fill="Width"),alpha=0.7)+
  geom_histogram(aes(x=b,fill="Height"),alpha=0.7)+
  geom_histogram(aes(x=th,fill="Orientation"),alpha=0.7)+
  geom_histogram(aes(x=col,fill="Color"),alpha=0.7)+
  guides(color=F)+labs(fill="Variable")
  theme_bw(15)
```
Once the variable count is above 2, individual density functions and a series of cross plots are easier to interpret than some multidimensional density hypervolume.
```{r, echo=FALSE,fig.cap="With Threshold Overlay",fig.height=4}
plot(grad.im[,c("a","b","th","col")])
```

Multiple Phases: Segmenting Shale
========================================================
% Shale provided from Kanitpanyacharoen, W. (2012). Synchrotron X-ray Applications Toward an Understanding of Elastic Anisotropy.
Here we have a shale sample with three different phases inside (clay, rock, and air).
```{r, echo=FALSE,fig.cap="Shale Sample"}
im.to.df<-function(in.img) {
    out.im<-expand.grid(x=1:nrow(in.img),y=1:ncol(in.img))
    out.im$val<-as.vector(in.img)
    out.im
}
shaleImage<-im.to.df(jpeg::readJPEG("ext-figures/ShaleSample.jpg"))
ggplot(shaleImage,aes(x=x,y=y,fill=val))+
  geom_tile()+
  labs(fill="Absorption")+theme_bw(20)
```
***
While there are 3 phases clearly visible in the image, the histogram is less telling (even after being re-scaled).
```{r, echo=FALSE}
ggplot(shaleImage,aes(x=val))+geom_histogram()+
  scale_y_sqrt()+
  labs(x="Absorption Intensity",y="Counts")+theme_bw(20)
```

Multiple Segmentations
========================================================
For this exercise we choose arbitrarily 3 ranges for the different phases and perform visual inspection
```{r, echo=FALSE}
void.max<-0.2
clay.max<-0.5
thresh.fun<-function(x.val) {
  if(x.val<void.max) "Void"
  else if (x.val>void.max & x.val<clay.max) "Clay"
  else "Rock"
}
shale.vals<-cbind(shaleImage,th.label=sapply(shaleImage$val,thresh.fun))
ggplot(shale.vals,aes(x=val))+geom_histogram(aes(fill=th.label))+
  scale_y_sqrt()+
  theme_bw(20)+labs(x="Intensity",y="Count")
```
***
The relation can explicitly be written out as
$$ I(x) = 
\begin{cases}
\text{Void}, & 0 \leq x \leq 0.2  \\
\text{Clay}, & 0.2 < x \leq 0.5 \\
\text{Rock}, & 0.5 < x
\end{cases}$$
```{r, echo=FALSE,fig.cap="Segmented Images"}
ggplot(shale.vals,aes(x=x,y=y,fill=th.label,alpha=1-val))+coord_fixed(ratio=1)+
  geom_raster()+guides(fill=F,alpha=F)+theme_bw(20)+facet_wrap(~th.label)
```


