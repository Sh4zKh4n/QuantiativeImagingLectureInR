```{r global_setup,  warning=FALSE, cache=FALSE,echo=FALSE,error=FALSE,results='hide'}
require(knitr)
# default settings, # settings for presentation version
echo.val<-F
fig.height<-5
dpi<-150
cache<-T
fig.path<-"pres_figures/"
cache.path<-"pres_cache/"

if(exists("printed")) { # settings for printed version (if the variable exists)
  echo.val<-T # show code
  fig.height<-3
  dpi<-150
  cache<-T
  fig.path<-"print_figures/"
  cache.path<-"print_cache/"
  }

opts_chunk$set(dpi=dpi,cache=cache,
               cache.path=cache.path,results='hide',
               warning=F,fig.align='center',echo=echo.val,
               fig.height=fig.height,fig.path=fig.path,message=F) #dev="CairoPNG"
```

```{r script_setup,results='hide',cache=FALSE}
require(ggplot2)
require(lattice) # nicer scatter plots
require(plyr)
require(grid) # contains the arrow function
require(biOps)
require(doMC) # for parallel code
require(EBImage)
## To install EBImage
# source("http://bioconductor.org/biocLite.R")
# biocLite("EBImage")

# start parallel environment
registerDoMC()
# functions for converting images back and forth
im.to.df<-function(in.img) {
  out.im<-expand.grid(x=1:nrow(in.img),y=1:ncol(in.img))
  out.im$val<-as.vector(in.img)
  out.im
  }
df.to.im<-function(in.df,val.col="val",inv=F) {
  in.vals<-in.df[[val.col]]
  if(class(in.vals[1])=="logical") in.vals<-as.integer(in.vals*255)
  if(inv) in.vals<-255-in.vals
  out.mat<-matrix(in.vals,nrow=length(unique(in.df$x)),byrow=F)
  attr(out.mat,"type")<-"grey"
  out.mat
  }
ddply.cutcols<-function(...,cols=1) {
  # run standard ddply command 
  cur.table<-ddply(...)
  cutlabel.fixer<-function(oVal) {
    sapply(oVal,function(x) {
      cnv<-as.character(x)
      mean(as.numeric(strsplit(substr(cnv,2,nchar(cnv)-1),",")[[1]]))
      })
    }
  cutname.fixer<-function(c.str) {
    s.str<-strsplit(c.str,"(",fixed=T)[[1]]
    t.str<-strsplit(paste(s.str[c(2:length(s.str))],collapse="("),",")[[1]]
    paste(t.str[c(1:length(t.str)-1)],collapse=",")
    }
  for(i in c(1:cols)) {
    cur.table[,i]<-cutlabel.fixer(cur.table[,i])
    names(cur.table)[i]<-cutname.fixer(names(cur.table)[i])
    }
  cur.table
  }

```

```{r utility_functions,results='hide',cache=FALSE}
## Standard image processing tools which I use for visualizing the examples in the script
commean.fun<-function(in.df) {
  ddply(in.df,.(val), function(c.cell) {
    weight.sum<-sum(c.cell$weight)
    data.frame(xv=mean(c.cell$x),
               yv=mean(c.cell$y),
               xm=with(c.cell,sum(x*weight)/weight.sum),
               ym=with(c.cell,sum(y*weight)/weight.sum)
               )
    })
  }

colMeans.df<-function(x,...) as.data.frame(t(colMeans(x,...)))

pca.fun<-function(in.df) {
  ddply(in.df,.(val), function(c.cell) {
    c.cell.cov<-cov(c.cell[,c("x","y")])
    c.cell.eigen<-eigen(c.cell.cov)
    
    c.cell.mean<-colMeans.df(c.cell[,c("x","y")])
    out.df<-cbind(c.cell.mean,
                  data.frame(vx=c.cell.eigen$vectors[1,],
                             vy=c.cell.eigen$vectors[2,],
                             vw=sqrt(c.cell.eigen$values),
                             th.off=atan2(c.cell.eigen$vectors[2,],c.cell.eigen$vectors[1,]))
                  )
    })
  }
vec.to.ellipse<-function(pca.df) {
  ddply(pca.df,.(val),function(cur.pca) {
    # assume there are two vectors now
    create.ellipse.points(x.off=cur.pca[1,"x"],y.off=cur.pca[1,"y"],
                          b=sqrt(5)*cur.pca[1,"vw"],a=sqrt(5)*cur.pca[2,"vw"],
                          th.off=pi/2-atan2(cur.pca[1,"vy"],cur.pca[1,"vx"]),
                          x.cent=cur.pca[1,"x"],y.cent=cur.pca[1,"y"])
    })
  }

# test function for ellipse generation
# ggplot(ldply(seq(-pi,pi,length.out=100),function(th) create.ellipse.points(a=1,b=2,th.off=th,th.val=th)),aes(x=x,y=y))+geom_path()+facet_wrap(~th.val)+coord_equal()
create.ellipse.points<-function(x.off=0,y.off=0,a=1,b=NULL,th.off=0,th.max=2*pi,pts=36,...) {
  if (is.null(b)) b<-a
  th<-seq(0,th.max,length.out=pts)
  data.frame(x=a*cos(th.off)*cos(th)+b*sin(th.off)*sin(th)+x.off,
             y=-1*a*sin(th.off)*cos(th)+b*cos(th.off)*sin(th)+y.off,
             id=as.factor(paste(x.off,y.off,a,b,th.off,pts,sep=":")),...)
  }
deform.ellipse.draw<-function(c.box) {
  create.ellipse.points(x.off=c.box$x[1],
                        y.off=c.box$y[1],
                        a=c.box$a[1],
                        b=c.box$b[1],
                        th.off=c.box$th[1],
                        col=c.box$col[1])                    
  }
bbox.fun<-function(in.df) {
  ddply(in.df,.(val), function(c.cell) {
    c.cell.mean<-colMeans.df(c.cell[,c("x","y")])
    xmn<-emin(c.cell$x)
    xmx<-emax(c.cell$x)
    ymn<-emin(c.cell$y)
    ymx<-emax(c.cell$y)
    out.df<-cbind(c.cell.mean,
                  data.frame(xi=c(xmn,xmn,xmx,xmx,xmn),
                             yi=c(ymn,ymx,ymx,ymn,ymn),
                             xw=xmx-xmn,
                             yw=ymx-ymn
                             ))
    })
  }

# since the edge of the pixel is 0.5 away from the middle of the pixel
emin<-function(...) min(...)-0.5
emax<-function(...) max(...)+0.5
extents.fun<-function(in.df) {
  ddply(in.df,.(val), function(c.cell) {
    c.cell.mean<-colMeans.df(c.cell[,c("x","y")])
    out.df<-cbind(c.cell.mean,data.frame(xmin=c(c.cell.mean$x,emin(c.cell$x)),
                                         xmax=c(c.cell.mean$x,emax(c.cell$x)),
                                         ymin=c(emin(c.cell$y),c.cell.mean$y),
                                         ymax=c(emax(c.cell$y),c.cell.mean$y)))
    })
  }

th_fillmap.fn<-function(max.val) scale_fill_gradientn(colours=rainbow(10),limits=c(0,max.val))
```



Quantitative Big Imaging 
========================================================
author: Kevin Mader
date: 3 April 2014
width: 1440
height: 900
css: ../template.css
transition: rotate

ETHZ: 227-0966-00L
# Many Objects and Distributions

Course Outline
========================================================
- 20th February - Introductory Lecture
- 27th February - Filtering and Image Enhancement (A. Kaestner)
- 6th March - Basic Segmentation, Discrete Binary Structures
- 13th March - Advanced Segmentation
- 20th March - Analyzing Single Objects
- 27th March -  Analyzing Complex Objects
- 3rd April -  **Many Objects and Distributions**
- 10th April -  Statistics and Reproducibility
- 17th April - Dynamic Experiments
- 8th May - Big Data
- 15th May - Guest Lecture - In-Operando Imaging of Batteries (V. Wood)
- 22th May - Project Presentations

Literature / Useful References
========================================================
### Books
- Jean Claude, Morphometry with R
- [Online](http://link.springer.com/book/10.1007%2F978-0-387-77789-4) through ETHZ
- [Buy it](http://www.amazon.com/Morphometrics-R-Use-Julien-Claude/dp/038777789X)
- John C. Russ, “The Image Processing Handbook”,(Boca Raton, CRC Press)
- Available [online](http://dx.doi.org/10.1201/9780203881095) within domain ethz.ch (or proxy.ethz.ch / public VPN) 

*** 
### Papers / Sites

- Voronoi Tesselations
 - Ghosh, S. (1997). Tessellation-based computational methods for the characterization and analysis of heterogeneous microstructures. Composites Science and Technology, 57(9-10), 1187–1210
 - [Wolfram Explanation](http://mathworld.wolfram.com/VoronoiDiagram.html)

- Alignment / Distribution Tensor
 - Mader, K. et al (2013). A quantitative framework for the 3D characterization of the osteocyte lacunar system. Bone, 57(1), 142–154

- Two point correlation
 - Dinis, L., et. al. (2007). Analysis of 3D solids using the natural neighbour radial point interpolation method. Computer Methods in Applied Mechanics and Engineering, 196(13-16)
 


Previously on QBI ...
========================================================

- Image Enhancment 
 - Highlighting the contrast of interest in images
 - Minimizing Noise
- Understanding image histograms
- Automatic Methods
- Component Labeling
- Single Shape Analysis
- Complicated Shapes

Outline
========================================================

- Motivation (Why and How?)
- Local Environment
 - Neighbors
 - Voronoi Tesselation
 - Distribution Tensor
 

***

- Global Enviroment
 - Alignment
 - Self-Avoidance
 - Two Point Correlation Function
 
 
What do we start with?
===
Going back to our original cell image

1. We have been able to get rid of the noise in the image and find all the cells (lecture 2-4)
1. We have analyzed the shape of the cells using the shape tensor (lecture 5)
1. We even separated cells joined together using Watershed (lecture 6)

We can characterize the sample and the average and standard deviations of volume, orientation, surface area, and other metrics

Motivation (Why and How?)
===

With all of these images, the first step is always to understand exactly what we are trying to learn from our images.

```{r, fig.cap="All Cells",fig.height=7}

cell.im<-jpeg::readJPEG("ext-figures/Cell_Colony.jpg")
cell.lab.df<-im.to.df(bwlabel(cell.im<.6))
size.histogram<-ddply(subset(cell.lab.df,val>0),.(val),function(c.label) data.frame(count=nrow(c.label)))
keep.vals<-subset(size.histogram,count>25)


cur.cell.df<-subset(cell.lab.df,val %in% keep.vals$val)
cell.pca<-pca.fun(cur.cell.df)
cell.ellipse<-vec.to.ellipse(cell.pca)
ggplot(cur.cell.df,aes(x=x,y=y))+
  geom_tile(color="black",fill="grey")+
  geom_path(data=cell.ellipse,aes(color="Ellipse",group=val))+
  geom_path(data=bbox.fun(cur.cell.df),aes(x=xi,y=yi,color="Bounding\nBox",group=val))+
  labs(title="Single Cell",color="Shape\nAnalysis\nMethod")+
  theme_bw(20)+coord_equal()+guides(fill=F)
```

***

1. We want to know how many cells are alive
 - Maybe small cells are dead and larger cells are alive $\rightarrow$ examine the volume distribution
 - Maybe living cells are round and dead cells are really spiky and pointy $\rightarrow$ examine anisotropy

1. We want to know where the cells are alive or most densely packed
 - We can visually inspect the sample (maybe even color by volume)
 - We can examine the raw positions (x,y,z) but what does that really tell us?
 - We can make boxes and count the cells inside each one
 - How do we compare two regions in the same sample or even two samples?

Motivation (continued)
===

```{r, fig.cap="All Cells",fig.height=7}
ggplot(cur.cell.df,aes(x=x,y=y))+
  geom_tile(color="black",fill="grey")+
  geom_path(data=cell.ellipse,aes(color="Ellipse",group=val))+
  geom_path(data=bbox.fun(cur.cell.df),aes(x=xi,y=yi,color="Bounding\nBox",group=val))+
  labs(title="Single Cell",color="Shape\nAnalysis\nMethod")+
  theme_bw(20)+coord_equal()+guides(fill=F)
```


***


1. We want to know how the cells are communicating
 - Maybe physically connected cells (touching) are communicating $\rightarrow$ watershed
 - Maybe cells oriented the same direction are communicating $\rightarrow$ _average?_ orientation
 - Maybe cells which are close __enough__ are communicating $\rightarrow$ __?__
 - Maybe cells form hub and spoke networks $\rightarrow$ __?__
 
1. We want to know how the cells are nourished
 - Maybe closely packed cells are better nourished $\rightarrow$ count cells in a box__?__
 - Maybe cells are oriented around canals which supply them $\rightarrow$ __?__


So what do we still need
===

1. A way for counting cells in a region and estimating density without creating arbitrary boxes
1. A way for finding out how many cells are _near_ a given cell, it's nearest neighbors
1. A way for quantifying how far apart cells are and then comparing different regions within a sample
1. A way for quantifying and comparing orientations
 - the mean of 0$^\circ$ and 180$^\circ$ = 90$^\circ$
 - the distance between -180$^\circ$ and 179$^\circ$ is 359$^\circ$
 - since we have not defined a tip or head, 0$^\circ$ and 180$^\circ$ are actually the same
 
***

### What would be really great? 

A tool which could be adapted to answering a large variety of problems
- multiple types of structures
- multiple phases




Ok, so now what?
===

```{r, fig.cap="Smaller Region",fig.height=4}
ggplot(cur.cell.df,aes(x=x,y=y))+
  geom_tile(color="black",fill="grey")+
  geom_path(data=cell.ellipse,aes(color="Ellipse",group=val))+
  labs(title="Zoomed into a smaller region")+
  xlim(200,400)+ylim(100,300)+
  theme_bw(20)+coord_equal()+guides(fill=F,color=F)
```

$$ \downarrow $$

```{r, results='asis'}
kable(head(cell.pca[,c("x","y","vx","vy")]),align='c',digits=2)
```

$$ \cdots $$
***

So if we want to know the the mean or standard deviations of the position or orientations we can analyze them easily. 


```{r, results='asis'}
cell.pca$Theta<-cell.pca$th.off*180/pi
cell.pca$Length<-cell.pca$vw
s.table<-apply(cell.pca[,c("x","y","Length","vx","vy","Theta")],2,summary)

kable(t(s.table),align='c',digits=2)
```

- But what if we want more or other information?

Neighbors
===

### Definition
 Oxford American $\rightarrow$ ```be situated next to or very near to (another)``` 
- Does not sound very scientific
- How close? 
 - Touching, closer than anything else?

### Nearest Neighbor (distance)
```{r nearest_neighbor} 
find.nn<-function(in.df) {
  ddply(in.df,.(val),function(c.group) {
    cur.val<-c.group$val[1]
    cur.x<-c.group$x[1]
    cur.y<-c.group$y[1]
    all.butme<-subset(in.df,val!=cur.val)
    all.butme$dist<-with(all.butme,sqrt((x-cur.x)^2+(y-cur.y)^2))
    min.ele<-subset(all.butme,dist<=min(all.butme$dist))
    min.ele.order<-order(runif(nrow(min.ele)))
    min.ele<-min.ele[min.ele.order,]
    out.df<-data.frame(x=cur.x,y=cur.y,
               xe=min.ele$x[1],ye=min.ele$y[1],vale=min.ele$val[1],dist=min.ele$dist[1])
    out.df
    })
}
```
Given a set of objects with centroids at 
$$ \textbf{P}=\begin{bmatrix} \vec{x}_0,\vec{x}_1,\cdots,\vec{x}_i \end{bmatrix} $$


***

We can define the nearest neighbor as the position of the object in our set which is closest

$$ \vec{\textrm{NN}}(\vec{y}) = \textrm{argmin}(||\vec{y}-\vec{x}|| \forall \vec{x} \in \textbf{P}-\vec{y}) $$

We define the distance as the Euclidean distance from the current point to that point, and the angle as the 

$$ \textrm{NND}(\vec{y}) = \textrm{min}(||\vec{y}-\vec{x}|| \forall \vec{x} \in \textbf{P}-\vec{y}) $$
$$ \textrm{NN}\theta(\vec{y}) = \tan^{-1}\frac{(\vec{\textrm{NN}}-\vec{y})\cdot \vec{j}}{(\vec{\textrm{NN}}-\vec{y})\cdot{i}} $$


Nearest Neighbor Definition
===

So examining a simple starting system like a grid, we already start running into issues. 
- In a perfect grid like structure each object has 4 equidistant neighbors (6 in 3D)
- Which one is closest?

We thus add an additional clause (only relevant for simulated data) where if there are multiple equidistant neighbors, a _nearest_ is chosen randomly

***

This ensures when we examine the orientation distribution (NN$\theta$) of the neighbors it is evenly distributed

```{r, fig.cap="Grid Nearest Neighbor",fig.height=4}
cur.grid<-expand.grid(x=-c(-4:4),y=c(-4:4))
cur.grid$val<-1:nrow(cur.grid)
ggplot(cur.grid,aes(x=x,y=y))+
  geom_segment(data=find.nn(cur.grid),aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Single Cell",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
  coord_equal()+
  theme_bw(20)+guides(fill=F)

```

In-Silico Systems
===

For the rest of these sections we will repeatedly use several simple in-silico systems to test our methods and try to better understand the kind of results we obtain from them.

- Compression
 - The most simple system simply involves a scaling in every direction by $\alpha$
 - $\alpha<1$ the system is compressed
 - $\alpha>1$ the system is expanded
 
 $$ \begin{bmatrix} x^\prime \\ y^\prime \end{bmatrix} = \alpha \begin{bmatrix} x \\ y \end{bmatrix} $$
 
 ***
 
- Shearing
 - Slightly more complicated system where objects are shifted based on their location using a slope of $\alpha$
 
 $$ \begin{bmatrix} x^\prime \\ y^\prime \end{bmatrix} = \begin{bmatrix} 1 & \alpha \\ 0 & 1 \end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} $$

 

In-Silico Systems (Continued)
===

- Stretch
 - A non-evenly distributed system with a parameter $\alpha$ controlling if objects bunch near the edges or the center. A maximum distance $m$ is defined as the magnitude of the largest offset in x or y
 - __+__ Same total volume just arranged differently
 
$$ \begin{bmatrix} x^\prime \\ y^\prime \end{bmatrix} = \begin{bmatrix} \textrm{sign}(x) \left(\frac{|x|}{m}\right)^\alpha m \\ \textrm{sign}(y) \left(\frac{|y|}{m}\right)^\alpha m \end{bmatrix} $$

***

- Swirl
 - A transformation where the points are rotated more based on how far away they are from the center and the slope of the swirl ($\alpha$), 
 
$$ \theta (x,y) = \alpha \sqrt{x^2+y^2} $$
 
$$ \begin{bmatrix} x^\prime \\ y^\prime \end{bmatrix} = 
\begin{bmatrix} \cos\theta(x,y) & -\sin\theta(x,y) \\
\sin\theta(x,y) & \cos\theta(x,y) 
\end{bmatrix} \begin{bmatrix} x \\ y \end{bmatrix} $$

Examining Compression
===
```{r, fig.cap="Uniaxially Stretched",fig.height=9}

test.systems.comp<-ldply(c(0.8,1,1.2),function(c.stretch) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,c.stretch*x)
  str.grid$y<-with(cur.grid,c.stretch*y)
  cbind(str.grid,glab=c.stretch)
})

dist.plots.comp<-ddply(test.systems.comp,.(glab),find.nn)
ggplot(test.systems.comp,aes(x=x,y=y))+
  geom_segment(data=dist.plots.comp,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}

ggplot(dist.plots.comp,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+guides(color=F)+
  theme_bw(20)
```

Compression Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}
ggplot(dist.plots.comp,      
       aes(x=dist,fill=as.factor(glab)))+
  #geom_density(size=1.5,adjust=1/5)+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",color="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```

***
 
```{r, fig.cap="NN Orientation",fig.height=9}
ggplot(dist.plots.comp,      
       aes(x=180/pi*atan2(ye-y,xe-x),fill=as.factor(glab)))+
  geom_histogram(binwidth=45)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",fill="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```


Examining Different Shears
===

```{r, fig.cap="Uniaxially Stretched",fig.height=9}

test.systems.shear<-ldply(c(0.5,1,3),function(c.shear) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,x+c.shear*(y-2)/2)
  cbind(str.grid,glab=c.shear)
})

dist.plots.shear<-ddply(test.systems.shear,.(glab),find.nn)
ggplot(test.systems.shear,aes(x=x,y=y))+
  geom_segment(data=dist.plots.shear,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}

ggplot(dist.plots.shear,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+guides(color=F)+
  theme_bw(20)
```

Shear Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}
ggplot(dist.plots.shear,      
       aes(x=dist,fill=as.factor(glab)))+
  #geom_density(size=1.5,adjust=1/5)+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",color="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```

***
 
```{r, fig.cap="NN Orientation",fig.height=9}
ggplot(dist.plots.shear,      
       aes(x=180/pi*atan2(ye-y,xe-x),fill=as.factor(glab)))+
  geom_histogram(binwidth=45)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",fill="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```


Examining Different Stretches
===

```{r, fig.cap="Uniaxially Stretched",fig.height=9}

str.fun<-function(x,a=1,r=4) sign(x)*r*(abs(x)/r)^a
test.systems<-ldply(c(0.5,1,3),function(c.stretch) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,str.fun(x,a=c.stretch))
  str.grid$y<-with(cur.grid,str.fun(y,a=c.stretch))
  cbind(str.grid,glab=c.stretch)
})

dist.plots<-ddply(test.systems,.(glab),find.nn)
ggplot(test.systems,aes(x=x,y=y))+
  geom_segment(data=dist.plots,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}

ggplot(dist.plots,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+guides(color=F)+
  theme_bw(20)
```

Stretch Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}
ggplot(dist.plots,      
       aes(x=dist,fill=as.factor(glab)))+
  #geom_density(size=1.5,adjust=1/5)+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",color="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```

***
 
```{r, fig.cap="NN Orientation",fig.height=9}
ggplot(dist.plots,      
       aes(x=180/pi*atan2(ye-y,xe-x),fill=as.factor(glab)))+
  geom_histogram(binwidth=45)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",fill="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```


Examining Swirl Systems
===

```{r, fig.cap="",fig.height=9}
cur.grid$cdist<-with(cur.grid,sqrt(x^2+y^2))
test.systems.swirl<-ldply(c(0,pi/40,pi/10),function(c.swirl) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,cos(c.swirl*cdist)*x-sin(c.swirl*cdist)*y)
  str.grid$y<-with(cur.grid,cos(c.swirl*cdist)*y+sin(c.swirl*cdist)*x)
  cbind(str.grid,glab=round(c.swirl*180/pi))
})

dist.plots.swirl<-ddply(test.systems.swirl,.(glab),find.nn)

ggplot(test.systems.swirl,aes(x=x,y=y))+
  geom_segment(data=dist.plots.swirl,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)+guides(fill=F)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}
ggplot(dist.plots.swirl,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+
  theme_bw(20)
```

Swirl NN Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}

ggplot(dist.plots.swirl,      
       aes(x=dist,fill=as.factor(glab)))+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",fill="Swirl")+
  scale_y_sqrt()+
  theme_bw(20)
```

***

```{r, fig.cap="NN Orientation",fig.height=9}

ggplot(dist.plots.swirl,      
       aes(x=180/pi*atan2(ye-y,xe-x),color=as.factor(glab)))+
  geom_density(aes(y=..scaled..),size=1,adjust=1/7)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",color="Swirl",y="Frequency")+
  #scale_y_sqrt()+
  theme_bw(20)
```


What we notice
===

We notice there are several fairly significant short-comings of these metrics (particularly with in-silico systems)

1. Orientation appears to be useful but random
 - Why should it matter if one side is 0.01% closer?
1. Single outlier objects skew results
1. We only extract one piece of information
1. Difficult to create metrics
 - Fit a peak to the angle distribution and measure the width as the "angle variability"?

Luckily we are not the first people to address this issue 

Random Systems
===

Using a uniform grid of points as a starting point has a strong influence on the results. A better approach is to use a randomly distributed series of points 
- resembles real data much better
- avoids these symmetry problems
 - $\epsilon$ sized edges or overlaps
 - identical distances to nearby objects
 
```{r use_random_grid}
cur.grid<-data.frame(x=runif(81,min=-4,max=4),y=runif(81,min=-4,max=4))
cur.grid$val<-1:nrow(cur.grid)
```

***

```{r, fig.cap="Maximum Stretch",fig.height=7,fig.width=9}
ggplot(cur.grid,aes(x=x,y=y))+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  theme_bw(20)
```


Examining Compression
===
```{r, fig.cap="Uniaxially Stretched",fig.height=9}

test.systems.comp<-ldply(c(0.8,1,1.2),function(c.stretch) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,c.stretch*x)
  str.grid$y<-with(cur.grid,c.stretch*y)
  cbind(str.grid,glab=c.stretch)
})

dist.plots.comp<-ddply(test.systems.comp,.(glab),find.nn)
ggplot(test.systems.comp,aes(x=x,y=y))+
  geom_segment(data=dist.plots.comp,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}

ggplot(dist.plots.comp,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+guides(color=F)+
  theme_bw(20)
```

Compression Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}
ggplot(dist.plots.comp,      
       aes(x=dist,fill=as.factor(glab)))+
  #geom_density(size=1.5,adjust=1/5)+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",color="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```

***
 
```{r, fig.cap="NN Orientation",fig.height=9}
ggplot(dist.plots.comp,      
       aes(x=180/pi*atan2(ye-y,xe-x),fill=as.factor(glab)))+
  geom_histogram(binwidth=45)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",fill="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```


Examining Different Shears
===

```{r, fig.cap="Uniaxially Stretched",fig.height=9}

test.systems.shear<-ldply(c(0.5,1,3),function(c.shear) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,x+c.shear*(y-2)/2)
  cbind(str.grid,glab=c.shear)
})

dist.plots.shear<-ddply(test.systems.shear,.(glab),find.nn)
ggplot(test.systems.shear,aes(x=x,y=y))+
  geom_segment(data=dist.plots.shear,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}

ggplot(dist.plots.shear,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+guides(color=F)+
  theme_bw(20)
```

Shear Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}
ggplot(dist.plots.shear,      
       aes(x=dist,fill=as.factor(glab)))+
  #geom_density(size=1.5,adjust=1/5)+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",color="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```

***
 
```{r, fig.cap="NN Orientation",fig.height=9}
ggplot(dist.plots.shear,      
       aes(x=180/pi*atan2(ye-y,xe-x),fill=as.factor(glab)))+
  geom_histogram(binwidth=45)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",fill="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```


Examining Different Stretches
===

```{r, fig.cap="Uniaxially Stretched",fig.height=9}

str.fun<-function(x,a=1,r=4) sign(x)*r*(abs(x)/r)^a
test.systems<-ldply(c(0.5,1,3),function(c.stretch) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,str.fun(x,a=c.stretch))
  str.grid$y<-with(cur.grid,str.fun(y,a=c.stretch))
  cbind(str.grid,glab=c.stretch)
})

dist.plots<-ddply(test.systems,.(glab),find.nn)
ggplot(test.systems,aes(x=x,y=y))+
  geom_segment(data=dist.plots,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}

ggplot(dist.plots,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+guides(color=F)+
  theme_bw(20)
```

Stretch Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}
ggplot(dist.plots,      
       aes(x=dist,fill=as.factor(glab)))+
  #geom_density(size=1.5,adjust=1/5)+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",color="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```

***
 
```{r, fig.cap="NN Orientation",fig.height=9}
ggplot(dist.plots,      
       aes(x=180/pi*atan2(ye-y,xe-x),fill=as.factor(glab)))+
  geom_histogram(binwidth=45)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",fill="Stretch")+
  scale_y_sqrt()+
  theme_bw(20)
```


Examining Swirl Systems
===

```{r, fig.cap="",fig.height=9}
cur.grid$cdist<-with(cur.grid,sqrt(x^2+y^2))
test.systems.swirl<-ldply(c(0,pi/40,pi/10),function(c.swirl) {
  str.grid<-cur.grid
  str.grid$x<-with(cur.grid,cos(c.swirl*cdist)*x-sin(c.swirl*cdist)*y)
  str.grid$y<-with(cur.grid,cos(c.swirl*cdist)*y+sin(c.swirl*cdist)*x)
  cbind(str.grid,glab=round(c.swirl*180/pi))
})

dist.plots.swirl<-ddply(test.systems.swirl,.(glab),find.nn)

ggplot(test.systems.swirl,aes(x=x,y=y))+
  geom_segment(data=dist.plots.swirl,aes(xend=xe,yend=ye),
               arrow=arrow(length = unit(0.3,"cm")),alpha=0.75)+
  geom_point(aes(color=val),size=3,alpha=0.75)+
  labs(title="Positions and Neighbors",color="Label")+
  scale_color_gradientn(colours=rainbow(10))+
    coord_equal()+
  facet_grid(glab~.)+
  theme_bw(20)+guides(fill=F)
```

***

```{r, fig.cap="Grid Nearest Neighbor",fig.height=9}
ggplot(dist.plots.swirl,
       aes(x=0,y=0,xend=xe-x,yend=ye-y))+
  geom_segment(aes(color=glab),
               arrow=arrow(length = unit(0.3,"cm")))+
  facet_grid(glab~.)+
    coord_equal()+
  labs(title="Nearest Neighbor Orientations")+
  theme_bw(20)
```

Swirl NN Distributions
===

```{r, fig.cap="Length Distribution",fig.height=9}

ggplot(dist.plots.swirl,      
       aes(x=dist,fill=as.factor(glab)))+
  geom_histogram(binwidth=0.25)+
  labs(x="NND",title="NN Distances",fill="Swirl")+
  scale_y_sqrt()+
  theme_bw(20)
```

***

```{r, fig.cap="NN Orientation",fig.height=9}

ggplot(dist.plots.swirl,      
       aes(x=180/pi*atan2(ye-y,xe-x),color=as.factor(glab)))+
  geom_density(aes(y=..scaled..),size=1,adjust=1/7)+
    labs(x=expression(paste("NN ",theta)),title="NN Orientation",color="Swirl",y="Frequency")+
  #scale_y_sqrt()+
  theme_bw(20)
```


Voronoi Tesselation
===
```{r voronoi_code}
library(deldir)
dd.summary<-function(in.df) ddply(in.df,.(glab),function(c.grid) {
  c.dd<-deldir(c.grid)
  c.vor<-c.dd$dirsgs
  n.pts<-as.vector(summary(as.factor(c(c.vor$ind1,c.vor$ind2))))
  n.vec<-data.frame(ind=1:length(n.pts),
                    n.count=n.pts,
                    area=c.dd$summary$dir.area)
  merge(c.grid,n.vec,by.x="val",by.y="ind")
})
```

Voronoi tesselation is a method for partitioning a space based on points. The basic idea is that each point $\vec{p}$ is assigned a region $\textbf{R}$ consisting of points which are closer to $\vec{p}$ than any of the other points. Below the diagram is shown in a dashed line for the points shown as small circles.

```{r, fig.cap="NN Orientation",fig.height=6}
plot(deldir(subset(test.systems,glab==1)),wlines=c('tess'),showrect=T)
```

***

### [Delaunay Triangulation](http://mathworld.wolfram.com/DelaunayTriangulation.html)

A parallel or _dual_ idea where triangles are used and each triangle is created such that the circle which encloses it contains no other points. The triangulation makes the _neighbors_ explcit since connected points in the triangulation correspond to points in our tesselation which share an edge (or face in 3D)

```{r, fig.cap="NN Orientation",fig.height=6}
plot(deldir(subset(test.systems,glab==1)),wlines=c('triang'))
```


Stretch System
===

```{r, fig.cap="Maximum Stretch",fig.height=7}
v.stretch<-quantile(test.systems$glab,0.95)
plot(deldir(subset(test.systems,glab>=v.stretch)),wlines=c('tess'),showrect=T)
```


***

```{r, fig.cap="Maximum Stretch",fig.height=7}
v.stretch<-quantile(test.systems$glab,0.5)
plot(deldir(subset(test.systems,glab==v.stretch)),wlines=c('tess'),showrect=T)
```


Swirl System
===

```{r, fig.cap="Maximum Stretch",fig.height=7}
v.stretch<-quantile(test.systems.swirl$glab,type=1,0.5)
plot(deldir(subset(test.systems.swirl,abs(glab-v.stretch)<0.1)),wlines=c('tess'),showrect=T)
```


***

```{r, fig.cap="Maximum Stretch",fig.height=7}
v.stretch<-quantile(test.systems.swirl$glab,0.95)
plot(deldir(subset(test.systems.swirl,glab==v.stretch)),wlines=c('tess'),showrect=T)
```


Neighborhoods
===

### Stretch 

```{r, fig.cap="Maximum Stretch",fig.height=7}
v.stretch<-quantile(test.systems$glab,0.9)
plot(deldir(subset(test.systems,glab==v.stretch)),wlines=c('triang'),showrect=T)
```

***
  
### Swirl

```{r, fig.cap="Maximum Stretch",fig.height=7}
v.stretch<-quantile(test.systems.swirl$glab,0.95)
plot(deldir(subset(test.systems.swirl,glab==v.stretch)),wlines=c('triang'),showrect=T)
```

Neighbor Count
===
```{r, fig.cap="Maximum Stretch",fig.height=7}
test.systems.vor<-dd.summary(test.systems)
ggplot(test.systems.vor,      
       aes(x=as.factor(n.count),y=..count..))+
  geom_histogram(aes(fill=as.factor(glab)),binwidth=1)+facet_grid(glab~.)+
  labs(x="Neighbors",title="Stretch Neighbor Count",fill="Swirl")+
 # scale_y_sqrt()+
  theme_bw(20)
```

***


```{r, fig.cap="Maximum Stretch",fig.height=7}
test.systems.swirl.vor<-dd.summary(test.systems.swirl)
ggplot(test.systems.swirl.vor,      
       aes(x=as.factor(n.count),y=..count..))+
  geom_histogram(aes(fill=as.factor(glab)),binwidth=1)+facet_grid(glab~.)+
  labs(x="Neighbors",title="Swirl Neighbor Count",fill="Swirl")+
 # scale_y_sqrt()+
  theme_bw(20)
```


Tile Area 
===
```{r, fig.cap="Maximum Stretch",fig.height=7}
ggplot(test.systems.vor,      
       aes(x=area,y=..count..))+
  geom_histogram(aes(fill=as.factor(glab)),binwidth=1)+facet_grid(glab~.)+
  labs(x="Area",title="Stretch Area Count",fill="Stretch")+
  theme_bw(20)
```

***


```{r, fig.cap="Maximum Stretch",fig.height=7}

ggplot(test.systems.swirl.vor,      
       aes(x=area,y=..count..))+
  geom_histogram(aes(fill=as.factor(glab)),binwidth=1)+facet_grid(glab~.)+
  labs(x="Area",title="Swirl Area",fill="Swirl")+
  theme_bw(20)
```

Using Both Metrics
===
```{r, fig.cap="Maximum Stretch",fig.height=7,fig.width=9}
ggplot(rbind(cbind(test.systems.vor,system="Stretch",cdist=0),
             cbind(test.systems.swirl.vor,system="Swirl")
             ),
       aes(x=area,y=n.count,color=glab,shape=as.factor(system)))+
  stat_binhex(bins=5)+
  geom_jitter()+
  
  #geom_density2d(alpha=0.5)+
  labs(x="Area",y="Neighbors",color="System")+
  scale_color_gradientn(colours=rainbow(4))+
  facet_grid(~system)+
  theme_bw(20)
```



